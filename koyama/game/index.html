<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- Ê§úÁ¥¢„Ç®„É≥„Ç∏„É≥Èô§Â§ñË®≠ÂÆö -->
    <meta name="robots" content="noindex, nofollow, noarchive">
    
    <!-- „Ç≠„É£„ÉÉ„Ç∑„É•ÁÑ°ÂäπÂåñË®≠ÂÆö -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    
    <meta charset="UTF-8">
    <!-- 1. Êã°Â§ß„ÉªÁ∏ÆÂ∞è„ÅÆÁ¶ÅÊ≠¢ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÈÄ≤ÊíÉ„ÅÆÂ∞èÂ±± - Koyama Attack</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a202c;
            color: white;
            overflow: hidden; 
            touch-action: none; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameCanvas {
            background-color: #87CEEB;
            border-bottom: 4px solid #2d3748;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            max-height: 80vh;
        }
        /* Mobile Controls */
        .controls-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25vh;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            user-select: none;
        }
        .d-pad {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .action-pad {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            transition: background 0.1s;
        }
        .btn:active, .btn.pressed {
            background: rgba(255, 255, 255, 0.5);
        }
        .btn-rect {
            width: 80px;
            border-radius: 10px;
            font-size: 14px;
        }
        .btn-beam {
            border-color: #00ffff;
            color: #00ffff;
        }
        
        #loadingScreen, #errorScreen, #startScreen, #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a202c;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        .hidden { display: none !important; }
        .text-shadow { text-shadow: 2px 2px 0 #000; }
        
        /* „Éú„ÇπÊà¶Ë≠¶ÂëäÁî® */
        #bossWarning {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            color: red;
            font-weight: bold;
            text-shadow: 4px 4px 0 #000, 0 0 20px red, 0 0 40px red;
            pointer-events: none;
            display: none;
            z-index: 5;
            animation: bossFlash 0.15s infinite alternate, bossScale 0.3s infinite alternate;
        }
        @keyframes bossFlash { 
            from { opacity: 1; text-shadow: 4px 4px 0 #000, 0 0 20px red, 0 0 40px red; } 
            to { opacity: 0.7; text-shadow: 4px 4px 0 #000, 0 0 40px yellow, 0 0 80px red; } 
        }
        @keyframes bossScale {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* „Çπ„ÉÜ„Éº„Ç∏„Ç¢„ÉÉ„ÉóÈÄöÁü•Áî® */
        #stageNotification {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #ffd700;
            font-weight: bold;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #ff6600;
            pointer-events: none;
            opacity: 0;
            z-index: 5;
            transition: opacity 0.3s ease;
        }
        #stageNotification.show {
            opacity: 1;
            animation: stageUp 0.5s ease-out;
        }
        @keyframes stageUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        /* „Çπ„ÉÜ„Éº„Ç∏„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥Ë°®Á§∫ */
        #stageCountdown {
            position: absolute;
            top: 40px;
            left: 4px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #87ceeb;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
            z-index: 0;
        }
        #stageCountdown .countdown-bar {
            width: 100px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin-top: 4px;
            overflow: hidden;
        }
        #stageCountdown .countdown-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00);
            border-radius: 4px;
            transition: width 0.1s linear;
        }
        
        /* BGM„Ç≥„É≥„Éà„É≠„Éº„É´ */
        #bgmControl {
            position: absolute;
            top: 120px;
            right: 10px;
            z-index: 20;
        }
        #bgmToggle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #bgmToggle.muted {
            opacity: 0.5;
        }

        /* „Çπ„Çø„Éº„ÉàÁîªÈù¢„ÅÆ„Éú„Çø„É≥„Ç≥„É≥„ÉÜ„Éä */
        .start-buttons-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }

        @media (min-width: 768px) {
            .start-buttons-container {
                flex-direction: row;
                justify-content: center;
            }
        }

        /* ÁÑ°ÂäπÂåñ„Åï„Çå„Åü„É≠„Éº„Éâ„Éú„Çø„É≥ */
        .load-btn:disabled {
            background-color: #6b7280 !important;
            border-color: #6b7280 !important;
            cursor: not-allowed !important;
            opacity: 0.7;
        }

        .load-btn:disabled:hover {
            background-color: #6b7280 !important;
        }

        /* „ÉÄ„É°„Éº„Ç∏„Ç™„Éº„Éê„Éº„É¨„Ç§ */
        #damageOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 0, 0, 0.6) 100%);
            pointer-events: none;
            opacity: 0;
            z-index: 4;
            transition: opacity 0.1s;
        }
        #damageOverlay.active {
            animation: damageFlash 0.3s ease-out;
        }
        @keyframes damageFlash {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>

    <!-- „ÉÄ„É°„Éº„Ç∏„Ç™„Éº„Éê„Éº„É¨„Ç§ -->
    <div id="damageOverlay"></div>

    <!-- BGM„Ç≥„É≥„Éà„É≠„Éº„É´ -->
    <div id="bgmControl">
        <button id="bgmToggle" title="BGM ON/OFF">‚ô™</button>
    </div>

    <!-- Game Canvas -->
    <div class="w-full h-full flex flex-col items-center justify-center relative">
        <div id="scoreBoard" class="absolute top-2 left-4 text-xl font-bold text-shadow z-0 pointer-events-none">SCORE: 0</div>
        <!-- „Çπ„ÉÜ„Éº„Ç∏„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ -->
        <div id="stageCountdown">
            Ê¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Åæ„Åß: <span id="countdownTime">20</span>Áßí
            <div class="countdown-bar">
                <div class="countdown-fill" id="countdownFill" style="width: 100%"></div>
            </div>
        </div>
        <!-- SAVE UI -->
        <div id="saveState" class="absolute top-2 left-72 text-sm font-bold text-yellow-300">SAVE: NONE</div>
        <button id="saveBtn" class="absolute top-10 left-72 px-2 py-1 bg-green-600 text-white rounded text-sm pointer-events-auto cursor-pointer">‰∏≠Êñ≠„Åô„Çã</button>

        <div id="hpBoard" class="absolute top-2 right-4 text-xl font-bold text-shadow z-0 pointer-events-none text-green-400">HP: 100</div>
        <!-- „Çπ„ÉÜ„Éº„Çø„ÇπË°®Á§∫„Ç®„É™„Ç¢ -->
        <div id="statusBoard" class="absolute top-12 right-4 text-sm font-bold text-shadow z-0 pointer-events-none text-yellow-300 text-right">
            PUNCH DMG: 1<br>
            BEAM MULTI: x1
        </div>
        
        <!-- „Éú„ÇπË≠¶Âëä„ÉÜ„Ç≠„Çπ„Éà -->
        <div id="bossWarning">„Ç®„É™„Ç¢„Éú„Çπ„ÅåÂá∫ÁèæÔºÅ<br><span style="font-size:2rem">„Ç¥„Éº„Çπ„ÉàÂ∞èÂ±±„ÇíË®é‰ºê„Åõ„ÇàÔºÅÔºÅ</span></div>
        
        <!-- „Çπ„ÉÜ„Éº„Ç∏„Ç¢„ÉÉ„ÉóÈÄöÁü• -->
        <div id="stageNotification">STAGE UP!</div>

        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Mobile Controls -->
    <div class="controls-area" id="mobileControls">
        <div class="d-pad">
            <div class="btn" id="btnLeft">‚Üê</div>
            <div class="btn" id="btnRight">‚Üí</div>
        </div>
        <div class="action-pad">
            <div class="btn btn-rect btn-beam" id="btnBeam">BEAM<br><span id="cdText" style="font-size:10px">(OK)</span></div>
            <div class="btn" id="btnPunch">üëä</div>
            <div class="btn" id="btnJump">JUMP</div>
        </div>
    </div>

    <!-- Screens -->
    <div id="loadingScreen">
        <h2 class="text-2xl mb-4">Ë™≠„ÅøËæº„Åø‰∏≠...</h2>
        <div class="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
    </div>

    <div id="errorScreen" class="hidden bg-red-900">
        <h2 class="text-3xl mb-2">„Ç®„É©„Éº</h2>
        <p id="errorMessage" class="text-center px-4">‰∏çÊòé„Å™„Ç®„É©„Éº</p>
        <button onclick="location.reload()" class="mt-6 px-4 py-2 bg-white text-red-900 rounded font-bold">„É™„É≠„Éº„Éâ</button>
    </div>

    <div id="startScreen" class="hidden">
        <h1 class="text-4xl md:text-6xl font-bold mb-6 text-yellow-400 text-shadow">ÈÄ≤ÊíÉ„ÅÆÂ∞èÂ±±</h1>
        <p class="mb-8 text-center px-4">
            Ëø´„Çä„Åè„Çã„ÄåÂ∞èÂ±±„Äç„ÇíÂÄí„ÅõÔºÅ<br>
            ÁßªÂãï: Áü¢Âç∞ / „Çø„ÉÉ„Éó<br>
            ÊîªÊíÉ: Z („Éë„É≥„ÉÅ), X („Éì„Éº„É†)<br>
            „Ç∏„É£„É≥„Éó: Space (2ÊÆµ„Ç∏„É£„É≥„ÉóÂèØ)<br>
            <span class="text-red-400 font-bold">9„Çπ„ÉÜ„Éº„Ç∏„Åî„Å®„Å´Âº∑Âäõ„Å™„Éï„É≠„Ç¢„Éú„Çπ„ÅåÂá∫ÁèæÔºÅ</span><br>
            „Éï„É≠„Ç¢„Éú„Çπ„ÅØÊµÆÈÅä„Åó„Å¶ÊîªÊíÉ„ÇíÂõûÈÅø„Åó„Å¶„Åè„Çã„ÅûÔºÅ
        </p>
        <!-- Ê®™‰∏¶„Å≥„Éú„Çø„É≥„Ç≥„É≥„ÉÜ„Éä -->
        <div class="start-buttons-container">
            <button id="startBtn" class="px-8 py-4 bg-green-600 text-white rounded-lg text-2xl font-bold hover:bg-green-500 shadow-lg transition w-full md:w-auto">„Ç≤„Éº„É†ÈñãÂßã</button>
            <button id="loadBtn" class="load-btn px-8 py-4 bg-blue-600 text-white rounded-lg text-2xl font-bold hover:bg-blue-500 shadow-lg transition w-full md:w-auto" disabled>„Çª„Éº„Éñ„Éá„Éº„Çø„Çí„É≠„Éº„Éâ</button>
        </div>
    </div>

    <div id="gameOverScreen" class="hidden bg-black bg-opacity-90">
        <h1 class="text-5xl text-red-500 font-bold mb-4">GAME OVER</h1>
        <p class="text-2xl mb-6">SCORE: <span id="finalScore">0</span></p>
        <button onclick="location.reload()" class="px-6 py-3 bg-white text-black rounded font-bold hover:bg-gray-200">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÈÅä„Å∂</button>
    </div>

    <script>
        // --- Constants & Config ---
        const ASSETS = {
            ENEMY_IMG: 'https://riverteacher.github.io/ohhhhhn/koyama/game/normal.png',
            RANGE_ENEMY_IMG: 'https://riverteacher.github.io/ohhhhhn/koyama/game/range.png',
            FLOOR_BOSS_IMG: 'https://riverteacher.github.io/ohhhhhn/koyama/game/boss.png',
            API_URL: 'https://riverteacher.github.io/ohhhhhn/koyama/game/status.html'
        };

        const SOUNDS = {
            BEAM: [
                'https://riverteacher.github.io/ohhhhhn/koyama/game/beam.wav',
            ],
            DAMAGE: [
                'https://riverteacher.github.io/ohhhhhn/koyama/game/damage1.mp3',
                'https://riverteacher.github.io/ohhhhhn/koyama/game/damage2.mp3'
            ],
            BOSS_KILLED: [
                'https://riverteacher.github.io/ohhhhhn/koyama/game/killed1.mp3',
                'https://riverteacher.github.io/ohhhhhn/koyama/game/killed2.mp3'
            ],
            BOSS_SUMMON: 'https://riverteacher.github.io/ohhhhhn/koyama/game/Ë≠¶ÂëäÈü≥2.mp3',
            GAME_OVER: 'https://riverteacher.github.io/ohhhhhn/koyama/game/dead.mp3',
            STAGE_UP: 'https://riverteacher.github.io/ohhhhhn/koyama/game/beam.wav'
        };

        // BGM URL„ÅÆÂÆöÁæ©„ÇíËøΩÂä†
        const BGM = {
            NORMAL: 'https://riverteacher.github.io/ohhhhhn/koyama/game/normal.mp3',
            BOSS: [
                'https://riverteacher.github.io/ohhhhhn/koyama/game/boss_1.mp3',
                'https://riverteacher.github.io/ohhhhhn/koyama/game/boss_2.mp3'
            ]
        };

        const GAME_CONFIG = {
            PLAYER_SPEED: 5,
            JUMP_FORCE: 12,
            GRAVITY: 0.6,
            GROUND_Y: 0,
            BEAM_COOLDOWN: 180,
            SPAWN_RATE: 100,
            PLAYER_MAX_HP: 10,
            PUNCH_DMG: 1,
            BASE_BEAM_DMG: 10,
            INVINCIBILITY_FRAMES: 60,
            
            ENEMY_SEEK_DURATION_ZAKO: 120,
            ENEMY_SEEK_DURATION_BOSS: 420,

            BASE_ZAKO_HP: 1, 
            BASE_BOSS_HP: 8,
            BASE_RANGE_HP: 9,
            
            HP_EXPONENTIAL_BASE: 1.038,
            HP_GROWTH_INITIAL_BOOST: 0.2,
            HP_GROWTH_DECAY: 0.14,

            STAGE_FRAME_DURATION: 1200, 
            IMAGE_SCALE: 1.25, 
            
            MAX_ENEMIES: 6,
            HEAL_AMOUNT: 2,

            FLOOR_BOSS_STAGE_INTERVAL: 8,
            FLOOR_BOSS_BASE_HP: 300,
            FLOOR_BOSS_HP_INCREASE_PERCENT: 0.4,
            FLOOR_BOSS_FLOAT_INTERVAL: 600,
            FLOOR_BOSS_FLOAT_DURATION: 120,
            FLOOR_BOSS_ACTION_INTERVAL: 180,
            FLOOR_BOSS_MOVE_SPEED: 0.5,
            
            BOSS_BEAM_HEIGHT: 40,
            BOSS_CEILING_BEAM_WIDTH: 30,
            BOSS_ATTACK_WARNING_FRAMES: 60,
            BOSS_ATTACK_ACTIVE_FRAMES: 30,
            BOSS_BEAM_DAMAGE: 3,
        };

        // --- Game State ---
        let canvas, ctx;
        let gameState = 'INIT'; 
        let frameCount = 0;
        let score = 0;
        
        let maedaImage = new Image();
        let rangeMaedaImage = new Image();
        let floorBossImage = new Image();

        // BGMÁî®„ÅÆAudio„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        let bgmNormal = null;
        let bgmBoss1 = null;
        let bgmBoss2 = null;
        let currentBGM = null;
        let isBossBGM = false;
        let isMuted = false;
        
        let currentStage = 1;
        let previousStage = 1;
        
        // Floor Boss State
        let isFloorBossActive = false;
        let floorBossCount = 0;

        // Screen Shake
        let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };

        // Input State
        const keys = {
            ArrowLeft: false, ArrowRight: false, ArrowUp: false, 
            KeyZ: false, KeyX: false, Space: false
        };
        const touchInput = {
            left: false, right: false, jump: false, punch: false, beam: false
        };

        // Entities
        let player = {
            x: 100, y: 0, w: 30, h: 60,
            vx: 0, vy: 0,
            hp: GAME_CONFIG.PLAYER_MAX_HP,
            facing: 1,
            beamCooldown: 0,
            invincibility: 0,
            color: 'white',
            punching: 0, 
            jumps: 2, 
            maxJumps: 2,
            punchDamage: GAME_CONFIG.PUNCH_DMG,
            beamMultiplier: 1, 
        };

        let enemies = [];
        let particles = [];
        let damageTexts = [];
        let projectiles = []; 

        // Sound System
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffers = {};

        // --- Screen Shake Function ---
        function triggerScreenShake(intensity, duration) {
            screenShake.intensity = intensity;
            screenShake.duration = duration;
        }

        function updateScreenShake() {
            if (screenShake.duration > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity * 2;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity * 2;
                screenShake.duration--;
                screenShake.intensity *= 0.95;
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
            }
        }

        // --- Damage Flash Effect ---
        function triggerDamageFlash() {
            const overlay = document.getElementById('damageOverlay');
            overlay.classList.remove('active');
            void overlay.offsetWidth; // Trigger reflow
            overlay.classList.add('active');
        }

        // --- BGMÈñ¢ÈÄ£„ÅÆÈñ¢Êï∞ ---
        function loadBGM(url) {
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.preload = 'auto';
                audio.src = url;
                
                audio.addEventListener('canplaythrough', () => {
                    resolve(audio);
                }, { once: true });
                
                audio.addEventListener('error', (e) => {
                    reject(new Error(`BGM„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó: ${url}`));
                }, { once: true });
                
                audio.load();
            });
        }

        function playBGM(bgmType) {
            if (isMuted || gameState !== 'PLAYING') return;
            
            if (currentBGM) {
                currentBGM.pause();
                currentBGM.currentTime = 0;
            }
            
            if (bgmType === 'normal' && bgmNormal) {
                currentBGM = bgmNormal;
                isBossBGM = false;
            } else if (bgmType === 'boss') {
                const bossBGM = Math.random() < 0.5 ? bgmBoss1 : bgmBoss2;
                currentBGM = bossBGM;
                isBossBGM = true;
            }
            
            if (currentBGM) {
                currentBGM.loop = true;
                currentBGM.volume = 0.5;
                currentBGM.play().catch(e => {
                    console.log('BGMÂÜçÁîü„Ç®„É©„Éº:', e);
                });
            }
        }

        function stopBGM() {
            if (currentBGM) {
                currentBGM.pause();
                currentBGM.currentTime = 0;
                currentBGM = null;
            }
            isBossBGM = false;
        }

        function toggleMute() {
            isMuted = !isMuted;
            const toggleBtn = document.getElementById('bgmToggle');
            
            if (isMuted) {
                toggleBtn.classList.add('muted');
                toggleBtn.textContent = '‚ô™';
                stopBGM();
            } else {
                toggleBtn.classList.remove('muted');
                toggleBtn.textContent = '‚ô™';
                if (gameState === 'PLAYING') {
                    if (isFloorBossActive) {
                        playBGM('boss');
                    } else {
                        playBGM('normal');
                    }
                }
            }
        }

        // --- „Çπ„ÉÜ„Éº„Ç∏„Ç¢„ÉÉ„ÉóÈÄöÁü•Èñ¢Êï∞ ---
        function showStageNotification(stage) {
            const notification = document.getElementById('stageNotification');
            notification.innerHTML = `STAGE ${stage}<br><span style="font-size:1.5rem">Èõ£ÊòìÂ∫¶‰∏äÊòáÔºÅ</span>`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        // --- „Çπ„ÉÜ„Éº„Ç∏„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥Êõ¥Êñ∞Èñ¢Êï∞ ---
        function updateStageCountdown() {
            const countdownEl = document.getElementById('stageCountdown');
            if (!countdownEl) return;
            
            if (isFloorBossActive) {
                countdownEl.innerHTML = '<span style="color: #ff6666;">‚öîÔ∏è „Éú„ÇπÊà¶‰∏≠ÔºÅ</span>';
                return;
            }
            
            const framesInCurrentStage = frameCount % GAME_CONFIG.STAGE_FRAME_DURATION;
            const remainingFrames = GAME_CONFIG.STAGE_FRAME_DURATION - framesInCurrentStage;
            const remainingSeconds = Math.ceil(remainingFrames / 60);
            
            const progress = (framesInCurrentStage / GAME_CONFIG.STAGE_FRAME_DURATION) * 100;
            
            const nextStage = currentStage + 1;
            const isNextBoss = nextStage % GAME_CONFIG.FLOOR_BOSS_STAGE_INTERVAL === 0;
            
            if (isNextBoss) {
                countdownEl.innerHTML = `<span style="color: #ff4444;">‚ö†Ô∏è „Éú„Çπ„Åæ„Åß: ${remainingSeconds}Áßí</span>
                    <div class="countdown-bar">
                        <div class="countdown-fill" style="width: ${100 - progress}%; background: linear-gradient(90deg, #ff0000, #ff6600);"></div>
                    </div>`;
            } else {
                countdownEl.innerHTML = `Ê¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Åæ„Åß: ${remainingSeconds}Áßí
                    <div class="countdown-bar">
                        <div class="countdown-fill" style="width: ${100 - progress}%;"></div>
                    </div>`;
            }
        }

        // --- Initialization ---
        window.onload = async () => {
            const loadingScreen = document.getElementById('loadingScreen');
            const errorScreen = document.getElementById('errorScreen');
            const startScreen = document.getElementById('startScreen');
            const errMsg = document.getElementById('errorMessage');

            try {
                const apiResponse = await fetch(ASSETS.API_URL);
                if (!apiResponse.ok) throw new Error(`API Status Error: ${apiResponse.status}`);
                const statusText = await apiResponse.text();
                
                if (statusText.trim().toLowerCase() !== 'allow') {
                    throw new Error(`„Ç≤„Éº„É†„ÅÆÂÆüË°å„ÅåË®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Çπ„ÉÜ„Éº„Çø„Çπ: ${statusText.trim()}`); 
                }

                await new Promise((resolve, reject) => {
                    let loaded = 0;
                    const total = 6;
                    const checkLoaded = () => { loaded++; if (loaded === total) resolve(); };

                    maedaImage.src = ASSETS.ENEMY_IMG;
                    maedaImage.onload = checkLoaded;
                    maedaImage.onerror = () => reject(new Error("„Éé„Éº„Éû„É´ÊïµÁîªÂÉè„ÅÆË™≠„ÅøËæº„ÅøÂ§±Êïó"));

                    rangeMaedaImage.src = ASSETS.RANGE_ENEMY_IMG;
                    rangeMaedaImage.onload = checkLoaded;
                    rangeMaedaImage.onerror = () => reject(new Error("ÈÅ†Ë∑ùÈõ¢ÊïµÁîªÂÉè„ÅÆË™≠„ÅøËæº„ÅøÂ§±Êïó"));

                    floorBossImage.src = ASSETS.FLOOR_BOSS_IMG;
                    floorBossImage.onload = checkLoaded;
                    floorBossImage.onerror = () => reject(new Error("„Éú„ÇπÁîªÂÉè„ÅÆË™≠„ÅøËæº„ÅøÂ§±Êïó"));

                    loadBGM(BGM.NORMAL).then(audio => {
                        bgmNormal = audio;
                        checkLoaded();
                    }).catch(err => reject(err));

                    loadBGM(BGM.BOSS[0]).then(audio => {
                        bgmBoss1 = audio;
                        checkLoaded();
                    }).catch(err => reject(err));

                    loadBGM(BGM.BOSS[1]).then(audio => {
                        bgmBoss2 = audio;
                        checkLoaded();
                    }).catch(err => reject(err));
                });

                loadingScreen.classList.add('hidden');
                startScreen.classList.remove('hidden');
                initGame();

            } catch (err) {
                loadingScreen.classList.add('hidden');
                errorScreen.classList.remove('hidden');
                errMsg.textContent = `„Ç®„É©„Éº: ${err.message}`;
            }
        };

        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            const resize = () => {
                canvas.width = Math.min(window.innerWidth, 800);
                canvas.height = Math.min(window.innerHeight * 0.75, 500);
                GAME_CONFIG.GROUND_Y = canvas.height - 40;
                player.y = GAME_CONFIG.GROUND_Y - player.h;
            };
            window.addEventListener('resize', resize);
            resize();

            setupInputs();
            
            document.getElementById('bgmToggle').addEventListener('click', toggleMute);
            
            document.getElementById('startBtn').addEventListener('click', () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                document.getElementById('startScreen').classList.add('hidden');
                gameState = 'PLAYING';
                
                if (!isMuted) {
                    playBGM('normal');
                }
                
                gameLoop();
            });
        }

        // Sound Functions
        function playSound(type) {
            let src = '';
            if (Array.isArray(SOUNDS[type])) {
                const idx = Math.floor(Math.random() * SOUNDS[type].length);
                src = SOUNDS[type][idx];
            } else {
                src = SOUNDS[type];
            }

            if (!src) return;

            const audio = new Audio(src);
            audio.volume = 0.5;
            audio.play().catch(e => console.log('Audio play failed:', e));
        }

        let isSpacePressed = false; 
        function setupInputs() {
            window.addEventListener('keydown', e => {
                if(e.code === 'Space' && !isSpacePressed) { 
                    keys.Space = true; 
                    isSpacePressed = true;
                    attemptJump(); 
                }
                if(e.code === 'ArrowLeft') keys.ArrowLeft = true;
                if(e.code === 'ArrowRight') keys.ArrowRight = true;
                if(e.code === 'KeyZ') { keys.KeyZ = true; attemptPunch(); }
                if(e.code === 'KeyX') { keys.KeyX = true; attemptBeam(); }
            });
            window.addEventListener('keyup', e => {
                if(e.code === 'Space') { keys.Space = false; isSpacePressed = false; }
                if(e.code === 'ArrowLeft') keys.ArrowLeft = false;
                if(e.code === 'ArrowRight') keys.ArrowRight = false;
                if(e.code === 'KeyZ') keys.KeyZ = false;
                if(e.code === 'KeyX') keys.KeyX = false;
            });

            const bindTouch = (id, key) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => { 
                    e.preventDefault(); 
                    touchInput[key] = true; 
                    el.classList.add('pressed'); 
                    if(key==='punch') attemptPunch(); 
                    if(key==='beam') attemptBeam(); 
                    if(key==='jump') attemptJump(); 
                }, {passive: false});
                el.addEventListener('touchend', (e) => { e.preventDefault(); touchInput[key] = false; el.classList.remove('pressed'); });
            };

            bindTouch('btnLeft', 'left');
            bindTouch('btnRight', 'right');
            bindTouch('btnJump', 'jump');
            bindTouch('btnPunch', 'punch');
            bindTouch('btnBeam', 'beam');

            document.addEventListener('touchstart', function(e) {
                if (e.target.closest('#mobileControls') || e.target.closest('#gameCanvas')) {
                    e.preventDefault();
                }
            }, {passive: false});
        }

        function attemptJump() {
            if (gameState !== 'PLAYING') return;

            if (player.y + player.h >= GAME_CONFIG.GROUND_Y - 1) {
                player.vy = -GAME_CONFIG.JUMP_FORCE;
                player.jumps = player.maxJumps - 1;
            } else if (player.jumps > 0) {
                player.vy = -GAME_CONFIG.JUMP_FORCE * 0.8; 
                player.jumps--;
                
                for(let i=0; i<3; i++) {
                    particles.push({
                        type: 'pixel',
                        x: player.x + player.w/2, y: player.y + player.h,
                        vx: (Math.random()-0.5)*4, vy: Math.random() * -3,
                        life: 15, color: '#ffff00'
                    });
                }
            }
        }

        // --- Enhanced Punch Effect ---
        function createPunchEffect(x, y, facing) {
            // Impact burst particles
            for(let i = 0; i < 12; i++) {
                const angle = (Math.PI / 6) * (i - 6) + (facing === 1 ? 0 : Math.PI);
                const speed = 4 + Math.random() * 6;
                particles.push({
                    type: 'punchSpark',
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 15 + Math.random() * 10,
                    maxLife: 25,
                    color: `hsl(${40 + Math.random() * 30}, 100%, ${50 + Math.random() * 30}%)`,
                    size: 3 + Math.random() * 4
                });
            }
            
            // Shockwave ring
            particles.push({
                type: 'shockwave',
                x: x,
                y: y,
                radius: 5,
                maxRadius: 50,
                life: 15,
                maxLife: 15,
                color: 'rgba(255, 200, 50, 0.8)'
            });
            
            // Impact flash
            particles.push({
                type: 'flash',
                x: x,
                y: y,
                radius: 30,
                life: 8,
                maxLife: 8,
                color: 'white'
            });
        }

        // --- Enhanced Beam Effect ---
        function createBeamEffect(startX, y, direction, width) {
            // Main beam particles along the path
            const particleCount = 30;
            for(let i = 0; i < particleCount; i++) {
                const px = direction === 1 ? startX + (width / particleCount) * i : startX - (width / particleCount) * i;
                particles.push({
                    type: 'beamParticle',
                    x: px + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 5 - 2,
                    life: 20 + Math.random() * 20,
                    maxLife: 40,
                    color: Math.random() > 0.5 ? '#00ffff' : '#ffffff',
                    size: 2 + Math.random() * 4
                });
            }
            
            // Electric sparks
            for(let i = 0; i < 15; i++) {
                particles.push({
                    type: 'electric',
                    x: startX + (Math.random() * width * direction),
                    y: y + (Math.random() - 0.5) * 40,
                    targetX: startX + (Math.random() * width * direction),
                    targetY: y + (Math.random() - 0.5) * 40,
                    life: 10 + Math.random() * 10,
                    maxLife: 20,
                    color: '#00ffff'
                });
            }
            
            // Muzzle flash
            particles.push({
                type: 'muzzleFlash',
                x: startX,
                y: y,
                life: 12,
                maxLife: 12,
                facing: direction
            });
        }

        // --- Player Actions ---
        function attemptPunch() {
            if (gameState !== 'PLAYING') return;
            player.punching = 10; 
            
            const punchRange = 60;
            const punchX = player.facing === 1 ? player.x + player.w : player.x - punchRange;
            const punchCenterX = player.facing === 1 ? player.x + player.w + 15 : player.x - 15;
            
            let hitAny = false;
            
            enemies.forEach(enemy => {
                const hitOffsetX = enemy.isBoss ? enemy.w * 0.2 : 0; 
                const hitOffsetY = enemy.isBoss ? enemy.h * 0.2 : 0; 

                if (enemy.type === 'floor_boss' && enemy.isFloating) {
                    return;
                }

                let heightTolerance = enemy.type === 'floor_boss' ? 100 : 50;

                if (
                    enemy.x + hitOffsetX < punchX + punchRange &&
                    enemy.x + enemy.w - hitOffsetX > punchX &&
                    Math.abs((enemy.y + enemy.h/2) - (player.y + player.h/2)) < (heightTolerance - hitOffsetY)
                ) {
                    hitEnemy(enemy, player.punchDamage);
                    hitAny = true;
                }
            });
            
            // Create punch effect
            createPunchEffect(punchCenterX, player.y + 30, player.facing);
            
            if (hitAny) {
                triggerScreenShake(4, 8);
            }
        }

        function attemptBeam() {
            if (gameState !== 'PLAYING') return;
            if (player.beamCooldown > 0) return;

            playSound('BEAM');

            player.beamCooldown = GAME_CONFIG.BEAM_COOLDOWN;
            let baseDamage = GAME_CONFIG.BASE_BEAM_DMG + (player.punchDamage * 2);
            const finalBeamDamage = baseDamage * player.beamMultiplier;

            let hitCount = 0;
            enemies.forEach(enemy => {
                if (enemy.type === 'floor_boss' && enemy.isFloating) {
                    return;
                }

                let hit = false;
                if (player.facing === 1 && enemy.x > player.x) hit = true;
                if (player.facing === -1 && enemy.x < player.x) hit = true;
                
                if (hit) {
                    hitEnemy(enemy, finalBeamDamage);
                    hitCount++;
                }
            });

            if (player.beamMultiplier > 1) {
                damageTexts.push({
                    x: player.x, y: player.y - 40, text: `„Éì„Éº„É†„ÅÆÂ®ÅÂäõ„ÅåÊàª„Çä„Åæ„Åó„Åü`, life: 60, vy: -1, color: '#00ffff'
                });
            }
            player.beamMultiplier = 1;

            // Enhanced beam particle
            const beamStartX = player.facing === 1 ? player.x + player.w : player.x;
            const beamWidth = player.facing === 1 ? canvas.width - player.x : player.x;
            
            particles.push({
                type: 'beam',
                x: player.facing === 1 ? player.x + player.w : 0,
                y: player.y + player.h/2 - 15,
                w: player.facing === 1 ? canvas.width - player.x : player.x,
                h: 30,
                life: 20,
                maxLife: 20,
                color: '#00ffff',
                facing: player.facing
            });
            
            // Create beam effects
            createBeamEffect(beamStartX, player.y + player.h/2, player.facing, beamWidth);
            
            // Screen shake on beam
            triggerScreenShake(6, 10);
        }
        
        function applyHealEffect() {
            const healAmount = GAME_CONFIG.HEAL_AMOUNT; 
            player.hp = Math.min(GAME_CONFIG.PLAYER_MAX_HP, player.hp + healAmount);
            damageTexts.push({
                x: player.x, y: player.y - 10, text: `+${healAmount} HP`, life: 40, vy: -1, color: '#00ff00'
            });
        }

        function applyPunchBuff() {
            player.punchDamage += 1;
            damageTexts.push({
                x: player.x, y: player.y - 20, text: `„Éë„É≥„ÉÅ„ÅÆÂ®ÅÂäõ„Åå‰∏ä„Åå„Çä„Åæ„Åó„ÅüÔºÅ`, life: 40, vy: -1.5, color: '#ffaa00'
            });
        }

        function applyBeamBuff() {
            player.beamMultiplier = 2;
            damageTexts.push({
                x: player.x, y: player.y - 30, text: `Ê¨°„ÅÆ„Éì„Éº„É†„ÅÆÂ®ÅÂäõ„ÅåÂÄç„Å´ÔºÅ`, life: 60, vy: -2, color: '#00ffff'
            });
        }

        function hitEnemy(enemy, dmg) {
            enemy.hp -= dmg;
            damageTexts.push({
                x: enemy.x, y: enemy.y, text: Math.floor(dmg), life: 30, vy: -2, color: 'white'
            });

            if (enemy.hp <= 0) {
                if (enemy.type === 'heal') {
                    const r = Math.random();
                    if (r < 0.5) applyHealEffect();
                    else if (r < 0.75) applyPunchBuff();
                    else applyBeamBuff();
                } else if (enemy.type === 'floor_boss') {
                    playSound('BOSS_KILLED');
                    
                    if (!isMuted) {
                        playBGM('normal');
                    }

                    score += 500 * (floorBossCount + 1);
                    isFloorBossActive = false;
                    currentStage++;
                    previousStage = currentStage;
                    
                    // Epic boss death effect
                    triggerScreenShake(15, 30);
                    for(let i=0; i<50; i++) {
                        const angle = (Math.PI * 2 / 50) * i;
                        const speed = 5 + Math.random() * 15;
                        particles.push({
                            type: 'bossDeathParticle',
                            x: enemy.x + enemy.w/2,
                            y: enemy.y + enemy.h/2,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 60 + Math.random() * 30,
                            maxLife: 90,
                            color: `hsl(${280 + Math.random() * 60}, 100%, ${50 + Math.random() * 30}%)`,
                            size: 5 + Math.random() * 10
                        });
                    }
                    
                    // Explosion rings
                    for(let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            particles.push({
                                type: 'explosionRing',
                                x: enemy.x + enemy.w/2,
                                y: enemy.y + enemy.h/2,
                                radius: 10,
                                maxRadius: 200 + i * 30,
                                life: 30,
                                maxLife: 30,
                                color: i % 2 === 0 ? 'purple' : 'magenta'
                            });
                        }, i * 100);
                    }
                } else {
                    score += enemy.isBoss ? 100 : (enemy.type === 'range' ? 30 : 10); 
                }
                
                const particleColor = enemy.type === 'heal' ? 'pink' : (enemy.type === 'range' ? 'blue' : 'red');
                if (enemy.type !== 'floor_boss') {
                    for(let i=0; i<8; i++) {
                        particles.push({
                            type: 'pixel',
                            x: enemy.x + enemy.w/2, y: enemy.y + enemy.h/2,
                            vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12,
                            life: 25, color: particleColor
                        });
                    }
                }
            } else {
                if (enemy.type !== 'floor_boss') {
                    enemy.x += (player.facing * 10);
                }
            }
        }

        // --- Enemy Spawning & Logic ---
        function getDifficultyMultiplier(stage) {
            let multiplier = 1;
            for (let i = 1; i < stage; i++) {
                const boost = GAME_CONFIG.HP_GROWTH_INITIAL_BOOST * Math.exp(-GAME_CONFIG.HP_GROWTH_DECAY * i);
                const currentRate = GAME_CONFIG.HP_EXPONENTIAL_BASE + boost;
                multiplier *= currentRate;
            }
            return multiplier;
        }

        function spawnEnemy() {
            if (isFloorBossActive) return;

            if (currentStage > 0 && currentStage % GAME_CONFIG.FLOOR_BOSS_STAGE_INTERVAL === 0) {
                spawnFloorBoss();
                return;
            }

            if (enemies.length >= GAME_CONFIG.MAX_ENEMIES) return;

            const r = Math.random();
            let enemyType = 'zako';
            
            if (r < 0.1) enemyType = 'boss';
            else if (r < 0.25) enemyType = 'range';
            else if (r < 0.35) enemyType = 'heal';
            
            const finalIsBoss = enemyType === 'boss';
            const finalIsRange = enemyType === 'range';

            if (finalIsBoss || finalIsRange) {
                const specialEnemyExists = enemies.some(e => e.isBoss || e.type === 'range');
                if (specialEnemyExists) {
                    enemyType = (Math.random() < 0.3) ? 'heal' : 'zako';
                }
            }

            const exponentialMultiplier = getDifficultyMultiplier(currentStage);
            
            let size, hp, speed, img;

            if (enemyType === 'boss') {
                size = 100;
                hp = Math.floor((Math.random() * 31 + GAME_CONFIG.BASE_BOSS_HP) * exponentialMultiplier);
                speed = 1; img = maedaImage;
            } else if (enemyType === 'heal') {
                size = 40;
                hp = Math.floor((Math.random() * 2 + 1) * exponentialMultiplier);
                speed = 3; img = maedaImage;
            } else if (enemyType === 'range') {
                size = 80; 
                hp = Math.floor((Math.random() * 4 + GAME_CONFIG.BASE_RANGE_HP) * exponentialMultiplier);
                speed = 0.5; img = rangeMaedaImage;
            } else {
                size = 40;
                hp = Math.floor((Math.random() * 3 + GAME_CONFIG.BASE_ZAKO_HP) * exponentialMultiplier);
                speed = 2; img = maedaImage;
            }

            const side = Math.random() < 0.5 ? -1 : 1;
            enemies.push({
                x: side === -1 ? -size : canvas.width + size,
                y: GAME_CONFIG.GROUND_Y - size,
                w: size, h: size,
                vx: speed,
                hp: hp, maxHp: hp,
                isBoss: enemyType === 'boss',
                type: enemyType,
                img: img,
                moveTimer: 0, 
                currentDirection: side === -1 ? 1 : -1,
                
                rangeAttackTimer: finalIsRange ? 0 : null,
                spikeState: finalIsRange ? 'idle' : null, 
                spikeWarningPos: finalIsRange ? 0 : null
            });
        }

        function spawnFloorBoss() {
            isFloorBossActive = true;
            floorBossCount++;

            enemies = enemies.filter(enemy => enemy.type === 'floor_boss');
            
            playSound('BOSS_SUMMON');
            
            if (!isMuted) {
                playBGM('boss');
            }
            
            // Boss appearance effects
            triggerScreenShake(10, 60);
            
            // Dark flash effect
            particles.push({
                type: 'bossAppearFlash',
                life: 30,
                maxLife: 30
            });
            
            // Warning particles
            for(let i = 0; i < 30; i++) {
                particles.push({
                    type: 'bossAppearParticle',
                    x: canvas.width - 100 + (Math.random() - 0.5) * 100,
                    y: GAME_CONFIG.GROUND_Y - 75 + (Math.random() - 0.5) * 150,
                    vx: (Math.random() - 0.5) * 8,
                    vy: -Math.random() * 5,
                    life: 60 + Math.random() * 60,
                    maxLife: 120,
                    color: `hsl(${Math.random() * 60}, 100%, 50%)`,
                    size: 3 + Math.random() * 5
                });
            }
            
            const warningEl = document.getElementById('bossWarning');
            warningEl.style.display = 'block';
            setTimeout(() => { warningEl.style.display = 'none'; }, 3000);

            const multiplier = Math.pow(1 + GAME_CONFIG.FLOOR_BOSS_HP_INCREASE_PERCENT, floorBossCount - 1);
            const maxHp = Math.floor(GAME_CONFIG.FLOOR_BOSS_BASE_HP * multiplier);

            const size = 150;
            enemies.push({
                type: 'floor_boss',
                x: canvas.width + 100,
                y: GAME_CONFIG.GROUND_Y - size,
                w: size, h: size,
                vx: GAME_CONFIG.FLOOR_BOSS_MOVE_SPEED,
                hp: maxHp, maxHp: maxHp,
                isBoss: true,
                img: floorBossImage,
                
                floatTimer: 0,
                isFloating: false,
                attackTimer: 0,
                attackState: 'idle',
                attackType: null,
                
                moveTimer: 0,
                currentDirection: -1,
                
                targetX: 0,
                appearanceFrame: 0
            });
        }

        // --- Floor Boss Logic ---
        function updateFloorBoss(e) {
            // Entrance animation
            e.appearanceFrame = (e.appearanceFrame || 0) + 1;
            
            const entryPositionX = canvas.width - 200;
            if (e.x > entryPositionX) {
                e.x -= 2;
                
                // Entry particles
                if (frameCount % 3 === 0) {
                    particles.push({
                        type: 'bossTrail',
                        x: e.x + e.w,
                        y: e.y + e.h / 2 + (Math.random() - 0.5) * e.h,
                        vx: 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 20,
                        maxLife: 20,
                        color: 'purple',
                        size: 5 + Math.random() * 5
                    });
                }
                return;
            }

            // Float logic
            e.floatTimer++;
            const floatCycle = GAME_CONFIG.FLOOR_BOSS_FLOAT_INTERVAL;
            const floatDuration = GAME_CONFIG.FLOOR_BOSS_FLOAT_DURATION;

            if (e.floatTimer % floatCycle > (floatCycle - floatDuration)) {
                if (!e.isFloating) {
                    e.isFloating = true;
                    e.targetY = 50;
                    
                    // Float start effect
                    for(let i = 0; i < 10; i++) {
                        particles.push({
                            type: 'floatParticle',
                            x: e.x + e.w/2 + (Math.random() - 0.5) * e.w,
                            y: e.y + e.h,
                            vx: (Math.random() - 0.5) * 3,
                            vy: Math.random() * 3 + 2,
                            life: 30,
                            maxLife: 30,
                            color: 'rgba(150, 0, 255, 0.8)',
                            size: 4
                        });
                    }
                }
                e.y += (e.targetY - e.y) * 0.1;
            } else {
                if (e.isFloating) {
                    e.isFloating = false;
                    e.targetY = GAME_CONFIG.GROUND_Y - e.h;
                }
                let groundY = GAME_CONFIG.GROUND_Y - e.h;
                if (Math.abs(e.y - groundY) > 1) {
                    e.y += (groundY - e.y) * 0.1;
                } else {
                    e.y = groundY;
                }
            }

            // Movement
            if (!e.isFloating) {
                const centerBoss = e.x + e.w / 2;
                const centerPlayer = player.x + player.w / 2;
                
                if (Math.abs(centerBoss - centerPlayer) > 50) { 
                    const moveDir = centerBoss < centerPlayer ? 1 : -1;
                    e.x += GAME_CONFIG.FLOOR_BOSS_MOVE_SPEED * moveDir;

                    if (e.x < 0) e.x = 0;
                    if (e.x + e.w > canvas.width) e.x = canvas.width - e.w;
                }
            }

            // Attack logic
            if (e.isFloating) return;

            e.attackTimer++;
            
            if (e.attackState === 'idle') {
                if (e.attackTimer > GAME_CONFIG.FLOOR_BOSS_ACTION_INTERVAL) {
                    e.attackState = 'warning';
                    e.attackTimer = 0;
                    
                    const r = Math.random();
                    if (r < 0.33) e.attackType = 'beam';
                    else if (r < 0.66) e.attackType = 'area';
                    else e.attackType = 'ceilingBeam';
                    
                    if (e.attackType === 'area' || e.attackType === 'ceilingBeam') {
                        e.targetX = player.x + player.w/2;
                    }
                    
                    // Warning effect particles
                    triggerScreenShake(3, 30);
                }
            } else if (e.attackState === 'warning') {
                // Charging particles
                if (frameCount % 5 === 0) {
                    const targetX = e.attackType === 'beam' ? e.x : e.targetX;
                    const targetY = e.attackType === 'ceilingBeam' ? 0 : GAME_CONFIG.GROUND_Y - 20;
                    
                    particles.push({
                        type: 'chargeParticle',
                        x: targetX + (Math.random() - 0.5) * 100,
                        y: targetY + (Math.random() - 0.5) * 50,
                        targetX: targetX,
                        targetY: targetY,
                        life: 20,
                        maxLife: 20,
                        color: e.attackType === 'beam' ? 'purple' : (e.attackType === 'area' ? 'orange' : 'red')
                    });
                }
                
                if (e.attackTimer > GAME_CONFIG.BOSS_ATTACK_WARNING_FRAMES) {
                    e.attackState = 'active';
                    e.attackTimer = 0;
                    
                    triggerScreenShake(8, 15);
                    
                    if (e.attackType === 'beam') {
                        // Enhanced boss beam
                        projectiles.push({
                            type: 'bossBeam',
                            x: canvas.width,
                            y: GAME_CONFIG.GROUND_Y - GAME_CONFIG.BOSS_BEAM_HEIGHT / 2,
                            w: canvas.width,
                            h: GAME_CONFIG.BOSS_BEAM_HEIGHT,
                            vx: -30, vy: 0,
                            damage: GAME_CONFIG.BOSS_BEAM_DAMAGE,
                            life: canvas.width / 30 + 10,
                            color: 'purple',
                            spawnTime: frameCount
                        });
                        
                        // Beam trail particles
                        for(let i = 0; i < 20; i++) {
                            particles.push({
                                type: 'bossBeamParticle',
                                x: canvas.width,
                                y: GAME_CONFIG.GROUND_Y - GAME_CONFIG.BOSS_BEAM_HEIGHT / 2 + (Math.random() - 0.5) * 60,
                                vx: -15 - Math.random() * 10,
                                vy: (Math.random() - 0.5) * 5,
                                life: 30 + Math.random() * 20,
                                maxLife: 50,
                                color: `hsl(${280 + Math.random() * 40}, 100%, ${50 + Math.random() * 30}%)`,
                                size: 3 + Math.random() * 5
                            });
                        }
                    } else if (e.attackType === 'area') {
                        projectiles.push({
                            type: 'explosion',
                            x: e.targetX, y: GAME_CONFIG.GROUND_Y,
                            w: 100, h: 150,
                            damage: 4,
                            life: GAME_CONFIG.BOSS_ATTACK_ACTIVE_FRAMES,
                            color: 'orange',
                            spawnTime: frameCount
                        });
                        
                        // Explosion particles
                        for(let i = 0; i < 25; i++) {
                            const angle = Math.random() * Math.PI;
                            const speed = 3 + Math.random() * 8;
                            particles.push({
                                type: 'explosionParticle',
                                x: e.targetX,
                                y: GAME_CONFIG.GROUND_Y - 20,
                                vx: Math.cos(angle) * speed * (Math.random() > 0.5 ? 1 : -1),
                                vy: -Math.sin(angle) * speed,
                                life: 30 + Math.random() * 20,
                                maxLife: 50,
                                color: `hsl(${30 + Math.random() * 30}, 100%, ${50 + Math.random() * 30}%)`,
                                size: 4 + Math.random() * 6
                            });
                        }
                    } else if (e.attackType === 'ceilingBeam') {
                        projectiles.push({
                            type: 'ceilingBeam',
                            x: e.targetX - GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH / 2, 
                            y: 0, 
                            w: GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH, 
                            h: GAME_CONFIG.GROUND_Y, 
                            vx: 0, vy: 0,
                            damage: GAME_CONFIG.BOSS_BEAM_DAMAGE,
                            life: GAME_CONFIG.BOSS_ATTACK_ACTIVE_FRAMES, 
                            color: 'red',
                            spawnTime: frameCount
                        });
                        
                        // Ceiling beam particles
                        for(let i = 0; i < 15; i++) {
                            particles.push({
                                type: 'ceilingBeamParticle',
                                x: e.targetX + (Math.random() - 0.5) * 40,
                                y: Math.random() * GAME_CONFIG.GROUND_Y,
                                vx: (Math.random() - 0.5) * 3,
                                vy: 5 + Math.random() * 5,
                                life: 20 + Math.random() * 15,
                                maxLife: 35,
                                color: `hsl(${Math.random() * 30}, 100%, ${50 + Math.random() * 30}%)`,
                                size: 3 + Math.random() * 4
                            });
                        }
                    }
                }
            } else if (e.attackState === 'active') {
                if (e.attackTimer > GAME_CONFIG.BOSS_ATTACK_ACTIVE_FRAMES) {
                    e.attackState = 'idle';
                    e.attackTimer = 0;
                }
            }
        }
        
        function handleRangedAttacks(e) {
            if (e.type !== 'range') return;

            e.rangeAttackTimer = (e.rangeAttackTimer + 1) % (60 * 60); 

            if (e.rangeAttackTimer % 180 === 0) {
                const startX = e.x + e.w / 2;
                const startY = e.y + e.h * 0.7; 
                const targetX = player.x + player.w / 2;
                let dir = targetX > startX ? 1 : -1;
                projectiles.push({
                    type: 'shortBeam',
                    x: startX, y: startY, w: 15, h: 8,
                    vx: dir * 6, vy: 0,
                    damage: 1, color: 'rgba(255, 165, 0, 0.9)',
                    life: 180
                });
                
                // Muzzle effect for range enemy
                for(let i = 0; i < 5; i++) {
                    particles.push({
                        type: 'pixel',
                        x: startX, y: startY,
                        vx: dir * (2 + Math.random() * 3),
                        vy: (Math.random() - 0.5) * 4,
                        life: 10,
                        color: 'orange'
                    });
                }
            }

            if (e.rangeAttackTimer % 300 === 0) {
                e.spikeState = 'warning';
                e.spikeWarningPos = player.x + player.w / 2;
                projectiles.push({
                    type: 'spike',
                    x: e.spikeWarningPos, y: GAME_CONFIG.GROUND_Y, 
                    w: 40, h: 0, damage: 2,
                    state: 'warning', life: 60, maxLife: 60,
                    owner: e 
                });
            }
        }

        function handlePlayerDamage(damage) {
            if (player.invincibility > 0) return;
            
            player.hp -= damage;
            player.invincibility = GAME_CONFIG.INVINCIBILITY_FRAMES;
            
            playSound('DAMAGE');
            
            // Enhanced damage effects
            triggerDamageFlash();
            triggerScreenShake(8, 15);
            
            // Damage particles from player
            for(let i = 0; i < 8; i++) {
                particles.push({
                    type: 'damageParticle',
                    x: player.x + player.w/2,
                    y: player.y + player.h/2,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 20,
                    maxLife: 20,
                    color: 'red',
                    size: 4 + Math.random() * 4
                });
            }

            if (player.hp <= 0) {
                playSound('GAME_OVER');
                stopBGM();

                gameState = 'GAMEOVER';
                document.getElementById('finalScore').textContent = score;
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];

                if (p.type === 'bossBeam') {
                    p.x += p.vx;
                    p.life--;
                    
                    // Trail particles
                    if (frameCount % 2 === 0) {
                        particles.push({
                            type: 'bossBeamTrail',
                            x: p.x,
                            y: p.y + (Math.random() - 0.5) * p.h,
                            vx: -2,
                            vy: (Math.random() - 0.5) * 3,
                            life: 15,
                            maxLife: 15,
                            color: 'purple',
                            size: 3
                        });
                    }
                    
                    if (player.invincibility <= 0) {
                        const beamY_top = p.y - p.h / 2;
                        const beamY_bottom = p.y + p.h / 2;
                        
                        if (
                            player.x < p.x && player.x + player.w > (p.x + p.vx) &&
                            player.y + player.h > beamY_top && player.y < beamY_bottom
                        ) {
                            handlePlayerDamage(p.damage);
                            damageTexts.push({ x: player.x, y: player.y, text: p.damage, life: 30, vy: -2, color: 'red' });
                        }
                    }
                    if (p.x + p.h < 0) p.life = 0;
                    
                } else if (p.type === 'explosion') {
                    p.life--;
                    if (player.invincibility <= 0 &&
                        player.x < p.x + p.w/2 && player.x + player.w > p.x - p.w/2 &&
                        player.y + player.h > GAME_CONFIG.GROUND_Y - p.h) {
                        handlePlayerDamage(p.damage);
                        damageTexts.push({ x: player.x, y: player.y, text: p.damage, life: 30, vy: -2, color: 'red' });
                    }
                } else if (p.type === 'ceilingBeam') {
                    p.life--;
                    
                    // Beam particles
                    if (frameCount % 2 === 0) {
                        particles.push({
                            type: 'ceilingBeamTrail',
                            x: p.x + p.w/2 + (Math.random() - 0.5) * 20,
                            y: Math.random() * p.h,
                            vx: (Math.random() - 0.5) * 2,
                            vy: 3,
                            life: 10,
                            maxLife: 10,
                            color: 'red',
                            size: 2
                        });
                    }
                    
                    if (player.invincibility <= 0 &&
                        player.x < p.x + p.w && player.x + player.w > p.x &&
                        player.y < p.y + p.h && player.y + player.h > p.y) {
                        handlePlayerDamage(p.damage);
                        damageTexts.push({ x: player.x, y: player.y, text: p.damage, life: 30, vy: -2, color: 'red' });
                    }
                } else if (p.type === 'shortBeam') {
                    p.x += p.vx;
                    p.life--;
                    
                    // Trail
                    if (frameCount % 3 === 0) {
                        particles.push({
                            type: 'pixel',
                            x: p.x, y: p.y,
                            vx: -p.vx * 0.2,
                            vy: (Math.random() - 0.5) * 2,
                            life: 10,
                            color: 'yellow'
                        });
                    }
                    
                    if (player.invincibility <= 0 &&
                        player.x < p.x + p.w && player.x + player.w > p.x &&
                        player.y < p.y + p.h && player.y + player.h > p.y) {
                        handlePlayerDamage(p.damage);
                        damageTexts.push({ x: player.x, y: player.y, text: p.damage, life: 30, vy: -2, color: 'red' });
                        p.life = 0;
                    }
                    if (p.x < 0 || p.x > canvas.width) p.life = 0;
                } else if (p.type === 'spike') {
                    p.life--;
                    if (p.state === 'warning') {
                        if (p.life <= 0) {
                            p.state = 'active';
                            p.life = 30;
                            p.h = 50;
                            
                            // Spike emerge effect
                            for(let j = 0; j < 8; j++) {
                                particles.push({
                                    type: 'pixel',
                                    x: p.x + (Math.random() - 0.5) * 30,
                                    y: GAME_CONFIG.GROUND_Y - 10,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: -Math.random() * 5 - 2,
                                    life: 15,
                                    color: '#654321'
                                });
                            }
                        }
                    } else if (p.state === 'active') {
                        if (player.invincibility <= 0 &&
                            player.x < p.x + p.w / 2 && player.x + player.w > p.x - p.w / 2 && 
                            player.y + player.h > p.y - p.h) { 
                            handlePlayerDamage(p.damage);
                            damageTexts.push({ x: player.x, y: player.y, text: p.damage, life: 30, vy: -2, color: 'red' });
                        }
                    }
                }
                
                if (p.life <= 0) {
                     projectiles.splice(i, 1);
                }
            }
        }


        function update() {
            if (gameState === 'GAMEOVER') return;

            frameCount++;
            updateScreenShake();

            if (!isFloorBossActive) {
                if (frameCount % GAME_CONFIG.STAGE_FRAME_DURATION === 0) {
                    currentStage++;
                }
            }
            
            if (currentStage > previousStage) {
                showStageNotification(currentStage);
                previousStage = currentStage;
            }
            
            updateStageCountdown();

            // Player Physics
            if (keys.ArrowLeft || touchInput.left) {
                player.vx = -GAME_CONFIG.PLAYER_SPEED;
                player.facing = -1;
            } else if (keys.ArrowRight || touchInput.right) {
                player.vx = GAME_CONFIG.PLAYER_SPEED;
                player.facing = 1;
            } else {
                player.vx = 0;
            }

            player.vy += GAME_CONFIG.GRAVITY;
            player.x += player.vx;
            player.y += player.vy;

            if (player.x < 0) player.x = 0;
            if (player.x + player.w > canvas.width) player.x = canvas.width - player.w;
            if (player.y + player.h > GAME_CONFIG.GROUND_Y) {
                player.y = GAME_CONFIG.GROUND_Y - player.h;
                player.vy = 0;
                player.jumps = player.maxJumps; 
            }

            if (player.beamCooldown > 0) player.beamCooldown--;
            if (player.punching > 0) player.punching--;
            if (player.invincibility > 0) player.invincibility--;

            // Enemies
            if (frameCount % GAME_CONFIG.SPAWN_RATE === 0) spawnEnemy();
            if (!isFloorBossActive && frameCount % 600 === 0 && GAME_CONFIG.SPAWN_RATE > 30) GAME_CONFIG.SPAWN_RATE -= 1;

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                
                if (e.type === 'floor_boss') {
                    updateFloorBoss(e);
                } else {
                    handleRangedAttacks(e); 
                    e.moveTimer++; 
                    const seekLimit = e.isBoss ? GAME_CONFIG.ENEMY_SEEK_DURATION_BOSS : GAME_CONFIG.ENEMY_SEEK_DURATION_ZAKO;
                    
                    if (e.type === 'range') {
                        if (Math.abs(e.x - player.x) > 300) {
                            e.currentDirection = (e.x + e.w/2 < player.x + player.w/2) ? 1 : -1;
                            e.x += e.vx * e.currentDirection;
                        }
                    } else if (e.moveTimer < seekLimit) {
                        e.currentDirection = (e.x + e.w/2 < player.x + player.w/2) ? 1 : -1;
                        e.x += e.vx * e.currentDirection;
                    } else {
                        if (e.x <= 0) e.currentDirection = 1;
                        else if (e.x + e.w >= canvas.width) e.currentDirection = -1;
                        e.x += e.vx * e.currentDirection;
                        if (e.x < 0) e.x = 0;
                        if (e.x + e.w > canvas.width) e.x = canvas.width - e.w;
                    }
                }

                if (e.type === 'floor_boss' && e.isFloating) {
                    // no collision
                } else {
                    const offsetX = e.isBoss ? e.w * 0.2 : 10;
                    const offsetY = e.isBoss ? e.h * 0.2 : 0;
                    
                    if (player.invincibility <= 0 && 
                        player.x < e.x + e.w - offsetX &&
                        player.x + player.w > e.x + offsetX &&
                        player.y < e.y + e.h - offsetY &&
                        player.y + player.h > e.y + offsetY
                    ) {
                        const dmg = e.type === 'floor_boss' ? 2 : 1;
                        
                        handlePlayerDamage(dmg);

                        player.vy = -5;
                        player.vx = (player.x < e.x) ? -10 : 10;
                    }
                }

                if (e.hp <= 0) enemies.splice(i, 1);
            }

            updateProjectiles();

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; 
                p.life--;
                
                if(p.type === 'pixel' || p.type === 'punchSpark' || p.type === 'beamParticle' || 
                   p.type === 'bossDeathParticle' || p.type === 'explosionParticle' ||
                   p.type === 'damageParticle' || p.type === 'bossAppearParticle' ||
                   p.type === 'floatParticle' || p.type === 'bossTrail' ||
                   p.type === 'bossBeamParticle' || p.type === 'bossBeamTrail' ||
                   p.type === 'ceilingBeamParticle' || p.type === 'ceilingBeamTrail') { 
                    p.x += p.vx; 
                    p.y += p.vy;
                    if (p.vy !== undefined && p.type !== 'floatParticle') p.vy += 0.1; // Gravity
                }
                
                if (p.type === 'shockwave' || p.type === 'explosionRing') {
                    p.radius += (p.maxRadius - p.radius) * 0.2;
                }
                
                if (p.type === 'chargeParticle') {
                    p.x += (p.targetX - p.x) * 0.15;
                    p.y += (p.targetY - p.y) * 0.15;
                }
                
                if (p.life <= 0) particles.splice(i, 1);
            }
            
            for (let i = damageTexts.length - 1; i >= 0; i--) {
                damageTexts[i].life--;
                damageTexts[i].y += damageTexts[i].vy;
                if (damageTexts[i].life <= 0) damageTexts.splice(i, 1);
            }
        }

        function draw() {
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);
            
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);
            
            // Boss fight background effect
            if (isFloorBossActive) {
                ctx.fillStyle = 'rgba(50, 0, 80, 0.4)';
                ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);
                
                // Pulsing vignette
                const pulseAlpha = 0.1 + Math.sin(frameCount * 0.05) * 0.05;
                const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width * 0.7);
                gradient.addColorStop(0, 'transparent');
                gradient.addColorStop(1, `rgba(100, 0, 150, ${pulseAlpha})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);
            }

            ctx.fillStyle = '#654321';
            ctx.fillRect(-10, GAME_CONFIG.GROUND_Y, canvas.width + 20, canvas.height - GAME_CONFIG.GROUND_Y + 20);

            // Draw particles (background layer)
            particles.forEach(p => {
                if (p.type === 'bossAppearFlash') {
                    const alpha = p.life / p.maxLife;
                    ctx.fillStyle = `rgba(100, 0, 150, ${alpha * 0.5})`;
                    ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);
                }
            });

            // Player
            if (player.invincibility % 4 < 2) { 
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(player.x + player.w/2, player.y + 10, 10, 0, Math.PI*2);
                ctx.moveTo(player.x + player.w/2, player.y + 20);
                ctx.lineTo(player.x + player.w/2, player.y + 45);
                ctx.moveTo(player.x + player.w/2, player.y + 45);
                ctx.lineTo(player.x + 5, player.y + player.h);
                ctx.moveTo(player.x + player.w/2, player.y + 45);
                ctx.lineTo(player.x + player.w - 5, player.y + player.h);
                ctx.moveTo(player.x + player.w/2, player.y + 30);
                if (player.punching > 0) {
                    ctx.lineTo(player.facing === 1 ? player.x + player.w + 15 : player.x - 15, player.y + 30);
                } else {
                    ctx.lineTo(player.x + (player.facing===1?25:5), player.y + 40);
                }
                ctx.stroke();
            }

            // Enemies
            enemies.forEach(e => {
                const baseScale = e.isBoss ? 2 : (e.type === 'range' ? 1.6 : 1);
                const scale = e.type === 'floor_boss' ? 1 : baseScale * GAME_CONFIG.IMAGE_SCALE;
                
                const drawW = e.w * (e.type === 'floor_boss' ? 1 : GAME_CONFIG.IMAGE_SCALE);
                const drawH = e.h * (e.type === 'floor_boss' ? 1 : GAME_CONFIG.IMAGE_SCALE);
                
                const drawX = e.x + (e.w - drawW) / 2; 
                const drawY = e.y + e.h - drawH; 
                
                if (e.type === 'heal') {
                    ctx.filter = 'hue-rotate(300deg) saturate(200%)'; 
                    if (frameCount % 20 < 10) {} else ctx.drawImage(e.img, drawX, drawY, drawW, drawH);
                } else if (e.type === 'range') {
                    ctx.filter = 'hue-rotate(180deg) saturate(150%) brightness(120%)';
                    ctx.drawImage(e.img, drawX, drawY, drawW, drawH);
                } else if (e.type === 'floor_boss') {
                    ctx.filter = 'none';
                    
                    // Boss glow effect
                    ctx.shadowColor = 'purple';
                    ctx.shadowBlur = 20 + Math.sin(frameCount * 0.1) * 10;
                    
                    if (e.isFloating) {
                        ctx.globalAlpha = 0.6 + Math.sin(frameCount * 0.15) * 0.2;
                        ctx.drawImage(e.img, drawX, drawY + Math.sin(frameCount * 0.1) * 10, drawW, drawH);
                        ctx.globalAlpha = 1.0;
                    } else {
                        ctx.drawImage(e.img, drawX, drawY, drawW, drawH);
                    }
                    
                    ctx.shadowBlur = 0;
                    
                    // Attack warning effects
                    if (e.attackState === 'warning') {
                        const warningProgress = e.attackTimer / GAME_CONFIG.BOSS_ATTACK_WARNING_FRAMES;
                        
                        if (e.attackType === 'beam') {
                            // Horizontal beam warning with pulsing
                            const beamY_center = GAME_CONFIG.GROUND_Y - GAME_CONFIG.BOSS_BEAM_HEIGHT / 2;
                            const pulseAlpha = 0.3 + Math.sin(frameCount * 0.3) * 0.2;
                            
                            // Gradient warning
                            const gradient = ctx.createLinearGradient(0, beamY_center - 30, 0, beamY_center + 30);
                            gradient.addColorStop(0, 'transparent');
                            gradient.addColorStop(0.3, `rgba(150, 0, 255, ${pulseAlpha})`);
                            gradient.addColorStop(0.5, `rgba(255, 0, 255, ${pulseAlpha * 1.5})`);
                            gradient.addColorStop(0.7, `rgba(150, 0, 255, ${pulseAlpha})`);
                            gradient.addColorStop(1, 'transparent');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(0, beamY_center - 40, canvas.width, 80);
                            
                            // Warning lines
                            ctx.strokeStyle = `rgba(255, 0, 255, ${0.5 + Math.sin(frameCount * 0.5) * 0.3})`;
                            ctx.lineWidth = 2;
                            ctx.setLineDash([10, 10]);
                            ctx.beginPath();
                            ctx.moveTo(0, beamY_center - GAME_CONFIG.BOSS_BEAM_HEIGHT/2);
                            ctx.lineTo(canvas.width, beamY_center - GAME_CONFIG.BOSS_BEAM_HEIGHT/2);
                            ctx.moveTo(0, beamY_center + GAME_CONFIG.BOSS_BEAM_HEIGHT/2);
                            ctx.lineTo(canvas.width, beamY_center + GAME_CONFIG.BOSS_BEAM_HEIGHT/2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            
                        } else if (e.attackType === 'area') {
                            // Area attack warning with expanding circles
                            const pulseSize = 30 + Math.sin(frameCount * 0.4) * 15;
                            
                            ctx.strokeStyle = `rgba(255, 150, 0, ${0.8})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(e.targetX, GAME_CONFIG.GROUND_Y - 10, 50 + pulseSize * warningProgress, 0, Math.PI, true);
                            ctx.stroke();
                            
                            ctx.fillStyle = `rgba(255, 100, 0, ${0.3 + Math.sin(frameCount * 0.3) * 0.15})`;
                            ctx.beginPath();
                            ctx.arc(e.targetX, GAME_CONFIG.GROUND_Y - 10, 50, 0, Math.PI, true);
                            ctx.fill();
                            
                            // Danger symbol
                            ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
                            ctx.font = 'bold 24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('‚ö†', e.targetX, GAME_CONFIG.GROUND_Y - 60);
                            
                        } else if (e.attackType === 'ceilingBeam') {
                            // Vertical beam warning
                            const gradient = ctx.createLinearGradient(e.targetX - 40, 0, e.targetX + 40, 0);
                            gradient.addColorStop(0, 'transparent');
                            gradient.addColorStop(0.3, `rgba(255, 0, 0, 0.3)`);
                            gradient.addColorStop(0.5, `rgba(255, 100, 0, 0.5)`);
                            gradient.addColorStop(0.7, `rgba(255, 0, 0, 0.3)`);
                            gradient.addColorStop(1, 'transparent');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(e.targetX - 50, 0, 100, GAME_CONFIG.GROUND_Y);
                            
                            // Warning dashes
                            ctx.strokeStyle = `rgba(255, 50, 0, ${0.7 + Math.sin(frameCount * 0.4) * 0.3})`;
                            ctx.lineWidth = 2;
                            ctx.setLineDash([15, 10]);
                            ctx.beginPath();
                            ctx.moveTo(e.targetX - GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH/2, 0);
                            ctx.lineTo(e.targetX - GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH/2, GAME_CONFIG.GROUND_Y);
                            ctx.moveTo(e.targetX + GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH/2, 0);
                            ctx.lineTo(e.targetX + GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH/2, GAME_CONFIG.GROUND_Y);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }

                } else if (e.isBoss) {
                    ctx.filter = 'saturate(150%) brightness(120%)';
                    ctx.drawImage(e.img, drawX, drawY, drawW, drawH);
                } else {
                    ctx.filter = 'none';
                    ctx.drawImage(e.img, drawX, drawY, drawW, drawH);
                }
                ctx.filter = 'none'; 

                // HP Bar
                if (e.isBoss || e.type === 'range' || e.hp < e.maxHp) {
                    const barY = drawY - 10; 
                    ctx.fillStyle = 'rgba(100, 0, 0, 0.8)';
                    ctx.fillRect(e.x, barY, e.w, 5); 
                    
                    let barColor = '#00ff00';
                    if (e.type === 'heal') barColor = 'pink';
                    else if (e.type === 'range') barColor = 'blue';
                    else if (e.type === 'floor_boss') barColor = 'purple';
                    
                    // Gradient HP bar
                    const hpGradient = ctx.createLinearGradient(e.x, barY, e.x + e.w * (e.hp / e.maxHp), barY);
                    hpGradient.addColorStop(0, barColor);
                    hpGradient.addColorStop(1, e.type === 'floor_boss' ? 'magenta' : barColor);
                    ctx.fillStyle = hpGradient;
                    ctx.fillRect(e.x, barY, e.w * (e.hp / e.maxHp), 5);
                }
            });

            // Projectiles
            projectiles.forEach(p => {
                if (p.type === 'shortBeam') {
                    // Enhanced short beam with glow
                    ctx.shadowColor = 'orange';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.ellipse(p.x + p.w/2, p.y + p.h/2, p.w/2, p.h/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'spike') {
                    if (p.state === 'warning') {
                        const flashAlpha = 0.5 + Math.sin(frameCount * 0.5) * 0.3;
                        ctx.fillStyle = `rgba(255, 0, 0, ${flashAlpha})`;
                        ctx.fillRect(p.x - 25, GAME_CONFIG.GROUND_Y - 8, 50, 8);
                        
                        // Warning cross
                        ctx.strokeStyle = `rgba(255, 200, 0, ${flashAlpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(p.x - 10, GAME_CONFIG.GROUND_Y - 20);
                        ctx.lineTo(p.x + 10, GAME_CONFIG.GROUND_Y - 20);
                        ctx.moveTo(p.x, GAME_CONFIG.GROUND_Y - 30);
                        ctx.lineTo(p.x, GAME_CONFIG.GROUND_Y - 10);
                        ctx.stroke();
                    } else if (p.state === 'active') {
                        // Multi-spike with gradient
                        const gradient = ctx.createLinearGradient(p.x, GAME_CONFIG.GROUND_Y, p.x, GAME_CONFIG.GROUND_Y - p.h);
                        gradient.addColorStop(0, '#333');
                        gradient.addColorStop(0.5, '#666');
                        gradient.addColorStop(1, '#999');
                        ctx.fillStyle = gradient;
                        
                        // Draw multiple spikes
                        for(let s = -1; s <= 1; s++) {
                            ctx.beginPath();
                            ctx.moveTo(p.x - p.w/3 + s * 15, GAME_CONFIG.GROUND_Y);
                            ctx.lineTo(p.x + p.w/3 + s * 15, GAME_CONFIG.GROUND_Y);
                            ctx.lineTo(p.x + s * 15, GAME_CONFIG.GROUND_Y - p.h * (s === 0 ? 1 : 0.7));
                            ctx.fill();
                        }
                    }
                } else if (p.type === 'bossBeam') {
                    if (p.life > 0) {
                        // Multi-layered beam effect
                        const beamY = p.y;
                        
                        // Outer glow
                        const outerGradient = ctx.createLinearGradient(0, beamY - p.h, 0, beamY + p.h);
                        outerGradient.addColorStop(0, 'transparent');
                        outerGradient.addColorStop(0.3, 'rgba(150, 0, 255, 0.3)');
                        outerGradient.addColorStop(0.5, 'rgba(200, 0, 255, 0.5)');
                        outerGradient.addColorStop(0.7, 'rgba(150, 0, 255, 0.3)');
                        outerGradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = outerGradient;
                        ctx.fillRect(0, beamY - p.h, p.x, p.h * 2);
                        
                        // Core beam
                        ctx.shadowColor = 'magenta';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = 'rgba(255, 100, 255, 0.9)';
                        ctx.fillRect(0, beamY - p.h/2, p.x, p.h);
                        
                        // Inner bright core
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.fillRect(0, beamY - p.h/4, p.x, p.h/2);
                        ctx.shadowBlur = 0;
                    }
                } else if (p.type === 'explosion') {
                    const progress = 1 - (p.life / GAME_CONFIG.BOSS_ATTACK_ACTIVE_FRAMES);
                    const radius = 50 + progress * 60;
                    
                    // Multi-ring explosion
                    for(let ring = 0; ring < 3; ring++) {
                        const ringRadius = radius - ring * 20;
                        if (ringRadius > 0) {
                            const alpha = (1 - progress) * (1 - ring * 0.3);
                            const gradient = ctx.createRadialGradient(p.x, GAME_CONFIG.GROUND_Y, 0, p.x, GAME_CONFIG.GROUND_Y, ringRadius);
                            gradient.addColorStop(0, `rgba(255, 255, 200, ${alpha})`);
                            gradient.addColorStop(0.5, `rgba(255, 150, 0, ${alpha * 0.8})`);
                            gradient.addColorStop(1, `rgba(255, 50, 0, 0)`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(p.x, GAME_CONFIG.GROUND_Y, ringRadius, Math.PI, 0, true);
                            ctx.fill();
                        }
                    }
                } else if (p.type === 'ceilingBeam') {
                    if (p.life > 0) {
                        // Vertical beam with lightning effect
                        const gradient = ctx.createLinearGradient(p.x, 0, p.x + p.w, 0);
                        gradient.addColorStop(0, 'rgba(255, 0, 0, 0.3)');
                        gradient.addColorStop(0.5, 'rgba(255, 200, 0, 0.9)');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0.3)');
                        
                        ctx.shadowColor = 'red';
                        ctx.shadowBlur = 30;
                        ctx.fillStyle = gradient;
                        ctx.fillRect(p.x - 10, p.y, p.w + 20, p.h);
                        
                        // Bright core
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.fillRect(p.x + p.w/4, p.y, p.w/2, p.h);
                        ctx.shadowBlur = 0;
                    }
                }
            });

            // Enhanced Particles
            particles.forEach(p => {
                const alpha = p.maxLife ? p.life / p.maxLife : 1;
                
                if (p.type === 'beam') {
                    // Multi-layer beam
                    const gradient = ctx.createLinearGradient(
                        p.facing === 1 ? p.x : p.x + p.w, p.y,
                        p.facing === 1 ? p.x + p.w : p.x, p.y
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(0.3, `rgba(0, 255, 255, ${alpha * 0.9})`);
                    gradient.addColorStop(1, `rgba(0, 200, 255, ${alpha * 0.3})`);
                    
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 30;
                    ctx.fillStyle = gradient;
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    
                    // Core
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                    ctx.fillRect(p.x, p.y + p.h/4, p.w, p.h/2);
                    ctx.shadowBlur = 0;
                    
                } else if (p.type === 'pixel' || p.type === 'punchSpark' || p.type === 'beamParticle' ||
                           p.type === 'bossDeathParticle' || p.type === 'explosionParticle' ||
                           p.type === 'damageParticle' || p.type === 'bossAppearParticle' ||
                           p.type === 'floatParticle' || p.type === 'bossTrail' ||
                           p.type === 'bossBeamParticle' || p.type === 'bossBeamTrail' ||
                           p.type === 'ceilingBeamParticle' || p.type === 'ceilingBeamTrail') {
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    const size = p.size || 4;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                } else if (p.type === 'shockwave' || p.type === 'explosionRing') {
                    ctx.strokeStyle = p.color.replace(')', `, ${alpha})`).replace('rgba', 'rgba').replace('rgb', 'rgba');
                    ctx.lineWidth = 4 * alpha;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                } else if (p.type === 'flash') {
                    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * (2 - alpha), 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (p.type === 'muzzleFlash') {
                    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x + p.facing * 40, p.y, 60);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(0.3, `rgba(0, 255, 255, ${alpha * 0.8})`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(p.x + p.facing * 20, p.y, 50 * alpha, 30 * alpha, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (p.type === 'electric') {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    const midX = (p.x + p.targetX) / 2 + (Math.random() - 0.5) * 30;
                    const midY = (p.y + p.targetY) / 2 + (Math.random() - 0.5) * 30;
                    ctx.quadraticCurveTo(midX, midY, p.targetX, p.targetY);
                    ctx.stroke();
                    
                } else if (p.type === 'chargeParticle') {
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });

            ctx.font = "bold 20px Arial";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            damageTexts.forEach(t => {
                ctx.fillStyle = t.color || "white";
                ctx.strokeText(t.text, t.x, t.y);
                ctx.fillText(t.text, t.x, t.y);
            });

            ctx.restore();

            // UI
            document.getElementById('scoreBoard').innerText = `SCORE: ${score} (Stage: ${currentStage})`;
            const hpEl = document.getElementById('hpBoard');
            hpEl.innerText = `HP: ${player.hp}`;
            hpEl.style.color = player.hp < 4 ? 'red' : 'lightgreen';

            const currentBaseBeamDmg = GAME_CONFIG.BASE_BEAM_DMG + (player.punchDamage * 2);
            document.getElementById('statusBoard').innerHTML = 
                `PUNCH DMG: ${player.punchDamage}<br>` +
                `BEAM DMG: ${currentBaseBeamDmg}<br>` +
                `BEAM MULTI: x${player.beamMultiplier}`;
            
            const cdText = document.getElementById('cdText');
            if (player.beamCooldown > 0) {
                cdText.innerText = Math.ceil(player.beamCooldown / 60);
                cdText.style.color = 'gray';
                document.getElementById('btnBeam').style.borderColor = 'gray';
            } else {
                cdText.innerText = 'OK';
                cdText.style.color = '#00ffff';
                document.getElementById('btnBeam').style.borderColor = '#00ffff';
            }
        }

        function gameLoop() {
            if (gameState === 'PLAYING') {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
        }

        /* Save/Load Logic (Cookie) */
        function _saveCookie(name, value) { document.cookie = name + '=' + encodeURIComponent(value) + '; max-age=' + (60*60*24*30) + '; path=/'; }
        function _loadCookie(name) { const m = document.cookie.match(new RegExp('(?:^|; )' + name + '=([^;]*)')); return m ? decodeURIComponent(m[1]) : null; }
        function _deleteCookie(name) { document.cookie = name + '=; max-age=0; path=/'; }
        
        function updateSaveStateUI(stateText) { const el = document.getElementById('saveState'); if (el) el.innerText = 'SAVE: ' + stateText; }

        function saveGameManual() {
            if (gameState !== 'PLAYING') return;

            try {
                const data = {
                    score: score,
                    playerHP: player.hp,
                    stage: currentStage,
                    punch: player.punchDamage,
                    beamMulti: player.beamMultiplier,
                    bossCount: floorBossCount
                };
                _saveCookie('koyamaSave', JSON.stringify(data));
                updateSaveStateUI('SAVED');
                
                stopBGM();
                
                const tempMessage = document.createElement('div');
                tempMessage.textContent = '„Çª„Éº„ÉñÂÆå‰∫ÜÔºÅ„Çø„Ç§„Éà„É´„Å´Êàª„Çä„Åæ„Åô...';
                tempMessage.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #48bb78; color: white; padding: 15px 30px; border-radius: 8px; z-index: 1000; font-size: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.3);';
                document.body.appendChild(tempMessage);
                
                setTimeout(() => {
                    document.body.removeChild(tempMessage);
                    location.reload(); 
                }, 1500);

            } catch (e) { 
                const tempMessage = document.createElement('div');
                tempMessage.textContent = '„Çª„Éº„ÉñÂ§±Êïó: ' + e.message;
                tempMessage.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #e53e3e; color: white; padding: 15px 30px; border-radius: 8px; z-index: 1000; font-size: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.3);';
                document.body.appendChild(tempMessage);
                setTimeout(() => {
                    document.body.removeChild(tempMessage);
                }, 3000);
            }
        }

        function loadGameData() {
            const raw = _loadCookie('koyamaSave');
            if (!raw) return false;
            try {
                const data = JSON.parse(raw);
                score = Number(data.score) || 0;
                player.hp = Number(data.playerHP) || player.hp;
                currentStage = Number(data.stage) || 1;
                previousStage = currentStage;
                player.punchDamage = Number(data.punch) || 1;
                player.beamMultiplier = Number(data.beamMulti) || 1;
                floorBossCount = Number(data.bossCount) || 0;
                updateSaveStateUI('LOADED');
                return true;
            } catch (e) { return false; }
        }

        function deleteSaveData() { _deleteCookie('koyamaSave'); updateSaveStateUI('NONE'); }

        window.addEventListener('load', () => {
            const raw = _loadCookie('koyamaSave');
            const loadBtn = document.getElementById('loadBtn');
            if (loadBtn) {
                if (raw) {
                    loadBtn.disabled = false;
                } else {
                    loadBtn.disabled = true;
                }
            }
            const saveBtn = document.getElementById('saveBtn');
            if (saveBtn) saveBtn.addEventListener('click', () => saveGameManual());
            
            if (loadBtn) loadBtn.addEventListener('click', () => {
                const raw = _loadCookie('koyamaSave');
                if (!raw) {
                    const tempMessage = document.createElement('div');
                    tempMessage.textContent = '„Çª„Éº„Éñ„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì';
                    tempMessage.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #e53e3e; color: white; padding: 15px 30px; border-radius: 8px; z-index: 1000; font-size: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.3);';
                    document.body.appendChild(tempMessage);
                    setTimeout(() => {
                        document.body.removeChild(tempMessage);
                    }, 3000);
                    return;
                }

                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                loadGameData();
                document.getElementById('startScreen').classList.add('hidden');
                gameState = 'PLAYING';
                
                if (!isMuted) {
                    playBGM('normal');
                }
                
                gameLoop();
            });
            
            if (raw) updateSaveStateUI('SAVED'); else updateSaveStateUI('NONE');
        });

        (function(){
            let handled = false;
            setInterval(() => {
                if (!handled && gameState === 'GAMEOVER') {
                    deleteSaveData();
                    handled = true;
                }
                if (handled && gameState !== 'GAMEOVER') handled = false;
            }, 250);
        })();

    </script>
</body>
</html>
