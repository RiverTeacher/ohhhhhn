<!DOCTYPE html>
<html lang="ja">
<head>
    <meta name="robots" content="noindex, nofollow, noarchive">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>„Åª„Çã„Å®„Ç¨„Ç§„Ç∏„Å™‰ª≤Èñì„Åü„Å°</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-dark: #1a202c;
            --sky-blue: #87CEEB;
            --ground-brown: #654321;
            --cyan: #00ffff;
            --warning-red: #ff4444;
        }
        body {
            background-color: var(--bg-dark);
            color: white;
            overflow: hidden;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameCanvas {
            background-color: var(--sky-blue);
            border-bottom: 4px solid #2d3748;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            max-height: 80vh;
        }
        .controls-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25vh;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            user-select: none;
        }
        .d-pad, .action-pad { display: flex; align-items: center; gap: 10px; }
        .action-pad { gap: 15px; }
        .btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            transition: background 0.1s;
        }
        .btn:active, .btn.pressed { background: rgba(255, 255, 255, 0.5); }
        .btn-rect { width: 80px; border-radius: 10px; font-size: 14px; }
        .btn-beam { border-color: var(--cyan); color: var(--cyan); }
        #loadingScreen, #errorScreen, #startScreen, #gameOverScreen {
            position: fixed;
            inset: 0;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        .hidden { display: none !important; }
        .text-shadow { text-shadow: 2px 2px 0 #000; }
        #bossWarning {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            color: red;
            font-weight: bold;
            text-shadow: 4px 4px 0 #000, 0 0 20px red, 0 0 40px red;
            pointer-events: none;
            display: none;
            z-index: 5;
            animation: bossFlash 0.15s infinite alternate, bossScale 0.3s infinite alternate;
        }
        @keyframes bossFlash { 
            from { opacity: 1; text-shadow: 4px 4px 0 #000, 0 0 20px red, 0 0 40px red; } 
            to { opacity: 0.7; text-shadow: 4px 4px 0 #000, 0 0 40px yellow, 0 0 80px red; } 
        }
        @keyframes bossScale {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.05); }
        }
        #stageNotification {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #ffd700;
            font-weight: bold;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #ff6600;
            pointer-events: none;
            opacity: 0;
            z-index: 5;
            transition: opacity 0.3s ease;
        }
        #stageNotification.show { opacity: 1; animation: stageUp 0.5s ease-out; }
        @keyframes stageUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        #stageCountdown {
            position: absolute;
            top: 40px;
            left: 4px;
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--sky-blue);
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
        #stageCountdown .countdown-bar {
            width: 100px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin-top: 4px;
            overflow: hidden;
        }
        #stageCountdown .countdown-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00);
            border-radius: 4px;
            transition: width 0.1s linear;
        }
        #bgmControl { position: absolute; top: 120px; right: 10px; z-index: 20; }
        #bgmToggle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #bgmToggle.muted { opacity: 0.5; }
        .start-buttons-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }
        @media (min-width: 768px) {
            .start-buttons-container { flex-direction: row; justify-content: center; }
        }
        .load-btn:disabled {
            background-color: #6b7280 !important;
            border-color: #6b7280 !important;
            cursor: not-allowed !important;
            opacity: 0.7;
        }
        #damageOverlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 0, 0, 0.6) 100%);
            pointer-events: none;
            opacity: 0;
            z-index: 4;
            transition: opacity 0.1s;
        }
        #damageOverlay.active { animation: damageFlash 0.3s ease-out; }
        @keyframes damageFlash { 0% { opacity: 0.8; } 100% { opacity: 0; } }
        #slowOverlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, rgba(0, 100, 255, 0.3) 0%, rgba(0, 50, 150, 0.5) 100%);
            pointer-events: none;
            opacity: 0;
            z-index: 3;
            transition: opacity 0.3s;
        }
        #slowOverlay.active { opacity: 1; }
        #fpsCounter {
            position: absolute;
            bottom: 26vh;
            left: 10px;
            font-size: 12px;
            color: #00ff00;
            text-shadow: 1px 1px 0 #000;
            z-index: 20;
            font-family: monospace;
        }
        .lite-mode-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        .lite-mode-toggle input[type="checkbox"] { width: 20px; height: 20px; cursor: pointer; }
        .lite-mode-toggle label { cursor: pointer; font-size: 14px; }
        #debuffIndicator {
            position: absolute;
            top: 80px;
            right: 10px;
            font-size: 14px;
            font-weight: bold;
            color: #00aaff;
            text-shadow: 1px 1px 0 #000;
            z-index: 20;
        }
    </style>
</head>
<body>
    <div id="damageOverlay"></div>
    <div id="slowOverlay"></div>
    <div id="bgmControl"><button id="bgmToggle" title="BGM ON/OFF">‚ô™</button></div>
    <div id="fpsCounter">FPS: --</div>
    <div id="debuffIndicator"></div>

    <div class="w-full h-full flex flex-col items-center justify-center relative">
        <div id="scoreBoard" class="absolute top-2 left-4 text-xl font-bold text-shadow z-0 pointer-events-none">SCORE: 0</div>
        <div id="stageCountdown">Ê¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Åæ„Åß: <span id="countdownTime">20</span>Áßí<div class="countdown-bar"><div class="countdown-fill" id="countdownFill" style="width: 100%"></div></div></div>
        <div id="saveState" class="absolute top-2 left-72 text-sm font-bold text-yellow-300">SAVE: NONE</div>
        <button id="saveBtn" class="absolute top-10 left-72 px-2 py-1 bg-green-600 text-white rounded text-sm pointer-events-auto cursor-pointer">‰∏≠Êñ≠„Åô„Çã</button>
        <div id="hpBoard" class="absolute top-2 right-4 text-xl font-bold text-shadow z-0 pointer-events-none text-green-400">HP: 100</div>
        <div id="statusBoard" class="absolute top-12 right-4 text-sm font-bold text-shadow z-0 pointer-events-none text-yellow-300 text-right">PUNCH DMG: 1<br>BEAM MULTI: x1</div>
        <div id="bossWarning">„Ç®„É™„Ç¢„Éú„Çπ„ÅåÂá∫ÁèæÔºÅ<br><span style="font-size:2rem">„Äé„Åª„Çã„Äè„ÇíË®é‰ºê„Åõ„ÇàÔºÅÔºÅ</span></div>
        <div id="stageNotification">STAGE UP!</div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="controls-area" id="mobileControls">
        <div class="d-pad">
            <div class="btn" id="btnLeft">‚Üê</div>
            <div class="btn" id="btnRight">‚Üí</div>
        </div>
        <div class="action-pad">
            <div class="btn btn-rect btn-beam" id="btnBeam">BEAM<br><span id="cdText" style="font-size:10px">(OK)</span></div>
            <div class="btn" id="btnPunch">üëä</div>
            <div class="btn" id="btnJump">JUMP</div>
        </div>
    </div>

    <div id="loadingScreen">
        <h2 class="text-2xl mb-4">Ë™≠„ÅøËæº„Åø‰∏≠...</h2>
        <div class="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
    </div>

    <div id="errorScreen" class="hidden bg-red-900">
        <h2 class="text-3xl mb-2">„Ç®„É©„Éº</h2>
        <p id="errorMessage" class="text-center px-4">‰∏çÊòé„Å™„Ç®„É©„Éº</p>
        <button onclick="location.reload()" class="mt-6 px-4 py-2 bg-white text-red-900 rounded font-bold">„É™„É≠„Éº„Éâ</button>
    </div>

    <div id="startScreen" class="hidden">
        <h1 class="text-4xl md:text-6xl font-bold mb-6 text-yellow-400 text-shadow">„Åª„Çã„Å®„Ç¨„Ç§„Ç∏„Å™‰ª≤Èñì„Åü„Å°</h1>
        <p class="mb-8 text-center px-4">
            Ëø´„Çä„Åè„Çã„Äå„Ç¨„Ç§„Ç∏„Äç„ÇíÂÄí„ÅõÔºÅ<br>
            ÁßªÂãï: Áü¢Âç∞ / „Çø„ÉÉ„Éó<br>
            ÊîªÊíÉ: Z („Éë„É≥„ÉÅ), X („Éì„Éº„É†)<br>
            „Ç∏„É£„É≥„Éó: Space (2ÊÆµ„Ç∏„É£„É≥„ÉóÂèØ)<br>
            <span class="text-red-400 font-bold">8„Çπ„ÉÜ„Éº„Ç∏„Åî„Å®„Å´Âº∑Âäõ„Å™„Éï„É≠„Ç¢„Éú„Çπ„ÅåÂá∫ÁèæÔºÅ</span><br>
            „Éï„É≠„Ç¢„Éú„Çπ„ÅØÂ§öÂΩ©„Å™ÊîªÊíÉ„Çí‰ªïÊéõ„Åë„Å¶„Åè„ÇãÔºÅ<br>
            <span class="text-blue-400">ÂºæÂπï„ÉªËøΩÂ∞æÂºæ„ÉªÁ™ÅÈÄ≤„ÉªÈÄüÂ∫¶‰Ωé‰∏ãÈ≠îÊ≥ï„Å´Ê≥®ÊÑèÔºÅ</span>
        </p>
        <div class="lite-mode-toggle">
            <input type="checkbox" id="liteModeCheck">
            <label for="liteModeCheck">üîß ËªΩÈáè„É¢„Éº„ÉâÔºà‰Ωé„Çπ„Éö„ÉÉ„ÇØPCÂêë„ÅëÔºöÊºîÂá∫„ÇíËªΩÊ∏õÔºâ</label>
        </div>
        <div class="start-buttons-container" style="margin-top: 20px;">
            <button id="startBtn" class="px-8 py-4 bg-green-600 text-white rounded-lg text-2xl font-bold hover:bg-green-500 shadow-lg transition w-full md:w-auto">„Ç≤„Éº„É†ÈñãÂßã</button>
            <button id="loadBtn" class="load-btn px-8 py-4 bg-blue-600 text-white rounded-lg text-2xl font-bold hover:bg-blue-500 shadow-lg transition w-full md:w-auto" disabled>„Çª„Éº„Éñ„Éá„Éº„Çø„Çí„É≠„Éº„Éâ</button>
        </div>
    </div>

    <div id="gameOverScreen" class="hidden bg-black bg-opacity-90">
        <h1 class="text-5xl text-red-500 font-bold mb-4">GAME OVER</h1>
        <p class="text-2xl mb-6">SCORE: <span id="finalScore">0</span></p>
        <button onclick="location.reload()" class="px-6 py-3 bg-white text-black rounded font-bold hover:bg-gray-200">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÈÅä„Å∂</button>
    </div>

    <script>
    (function() {
        'use strict';
        
        // Constants
        const ASSETS = {
            ENEMY_IMG: 'https://riverteacher.github.io/ohhhhhn/koyama/game/emoji_4.png',
            RANGE_ENEMY_IMG: 'https://riverteacher.github.io/ohhhhhn/koyama/game/emoji_1.png',
            FLOOR_BOSS_IMG: 'https://riverteacher.github.io/ohhhhhn/koyama/game/emoji_3.png',
            API_URL: 'https://riverteacher.github.io/ohhhhhn/koyama/game/status.html'
        };

        const SOUNDS = {
            BEAM: ['https://riverteacher.github.io/ohhhhhn/koyama/game/beam.wav'],
            DAMAGE: ['https://riverteacher.github.io/ohhhhhn/koyama/game/„Éä„Ç§„Éï„ÅßÁ™Å„ÅçÂà∫„Åô2.mp3', 'https://riverteacher.github.io/ohhhhhn/koyama/game/„Éä„Ç§„Éï„ÅßÁ™Å„ÅçÂà∫„Åô3.mp3'],
            BOSS_KILLED: ['https://riverteacher.github.io/ohhhhhn/koyama/game/‰∏≠„Éë„É≥„ÉÅ.mp3', 'https://riverteacher.github.io/ohhhhhn/koyama/game/Â§ß„Ç≠„ÉÉ„ÇØ.mp3'],
            BOSS_SUMMON: 'https://riverteacher.github.io/ohhhhhn/koyama/game/Ë≠¶ÂëäÈü≥2.mp3',
            GAME_OVER: 'https://riverteacher.github.io/ohhhhhn/koyama/game/ÈáéÁç£„Äå„ÅÇ„ÅÇ„ÅÇ„ÅÇ„ÅÇ„Äç.mp3',
            STAGE_UP: 'https://riverteacher.github.io/ohhhhhn/koyama/game/beam.wav'
        };

        const BGM = {
            NORMAL: 'https://riverteacher.github.io/ohhhhhn/koyama/game/normal.mp3',
            BOSS: ['https://riverteacher.github.io/ohhhhhn/koyama/game/boss_1.mp3', 'https://riverteacher.github.io/ohhhhhn/koyama/game/boss_2.mp3']
        };

        // „Éú„Çπ„ÅÆ„Çª„É™„ÉïÂÆöÁæ©
        const BOSS_ATTACK_LINES = {
            beam: ['„Åè„Çâ„ÅàÔºÅÊ®™Ëñô„Åé„Éì„Éº„É†ÔºÅ', 'Â§©Êâç„Ç§„Ç±„É°„É≥„Éè„ÉÉ„Ç´„Éº„Åª„ÇãÊßò„ÅÆ„Éì„Éº„É†„Çí„Åè„Çâ„ÅàÔºÅ', 'ÈÄÉ„Åí„Çâ„Çå„Çã„Åã„Å™Ôºü'],
            area: ['Â§ßÂú∞„ÇíÁÑº„ÅçÂ∞Ω„Åè„ÅõÔºÅ', '„Åù„ÅÆÂ†¥ÊâÄ„ÅØÂç±Èô∫„Å†„ÅûÔºÅ', 'Ê≠ª„Å≠„Éº„Éº„Éº„Éº„Éº„Éº„Éº„Éº„Éº„Éº„Éº„ÉºÔºÅ'],
            ceilingBeam: ['„ÅÜ„ÅäÔΩó', '‰∏ä„Åã„ÇâÊù•„Çã„ÅûÔºÅ', 'ÈÄÉ„ÅíÂ†¥„ÅØ„Å™„ÅÑÔºÅ'],
            homing: ['„Åö„Å£„Å®‰∏ÄÁ∑í„Å†„Çà‚ô°', '„Å©„Åì„Åæ„Åß„ÇÇËøΩ„ÅÑ„Åã„Åë„Çã„ÅûÔºÅ', '„Åì„Çå„ÅØÈÅø„Åë„Çâ„Çå„Åæ„ÅÑÔºÅ'],
            charge: ['Á™ÅÊíÉ„ÅÉ„ÅÉ„ÅÉÔºÅ', '„Å∂„Å£È£õ„Å∞„ÅôÔºÅ', 'ËìÑ„Åà„Åü‰ΩìÈáç„Çí‰ªäÁô∫ÊèÆ„Åô„ÇãÔºÅÔºÅ'],
            slowMagic: ['Âãï„Åç„ÇíÂ∞Å„Åò„ÇãÔºÅ', '„Åì„Åì„ÅßÁµÇ„Çè„Çä„Å†ÔºÅ', 'Ë∂≥„ÇíÊ≠¢„ÇÅ„Å¶„ÇÑ„ÇãÔºÅ'],
            barrage: ['ÂºæÂπï„Å†ÔºÅ', 'ÈÅø„Åë„Åç„Çå„Çã„Åã„Å™Ôºü', 'ÈõëÈ≠ö‰πô']
        };

        // Game Configuration - 1Ë°å„Åö„Å§Ë®òËø∞
        const GAME_CONFIG = {
            // „Éó„É¨„Ç§„É§„ÉºË®≠ÂÆö
            PLAYER_SPEED: 5,
            PLAYER_SLOW_SPEED: 2,
            JUMP_FORCE: 12,
            GRAVITY: 0.6,
            GROUND_Y: 0,
            PLAYER_MAX_HP: 10,
            INVINCIBILITY_FRAMES: 60,
            
            // ÊîªÊíÉË®≠ÂÆö
            BEAM_COOLDOWN: 180,
            PUNCH_DMG: 1,
            BASE_BEAM_DMG: 10,
            
            // Êïµ„Çπ„Éù„Éº„É≥Ë®≠ÂÆö
            SPAWN_RATE: 100,
            MAX_ENEMIES: 6,
            
            // ÊïµAIË®≠ÂÆö
            ENEMY_SEEK_DURATION_ZAKO: 120,
            ENEMY_SEEK_DURATION_BOSS: 420,
            
            // ÊïµHPË®≠ÂÆö
            BASE_ZAKO_HP: 1,
            BASE_BOSS_HP: 8,
            BASE_RANGE_HP: 9,
            
            // Èõ£ÊòìÂ∫¶Ë®≠ÂÆö
            HP_EXPONENTIAL_BASE: 1.038,
            HP_GROWTH_INITIAL_BOOST: 0.2,
            HP_GROWTH_DECAY: 0.14,
            
            // „Çπ„ÉÜ„Éº„Ç∏Ë®≠ÂÆö
            STAGE_FRAME_DURATION: 1200,
            
            // Ë°®Á§∫Ë®≠ÂÆö
            IMAGE_SCALE: 1.25,
            
            // ÂõûÂæ©Ë®≠ÂÆö
            HEAL_AMOUNT: 2,
            
            // „Éï„É≠„Ç¢„Éú„ÇπÂü∫Êú¨Ë®≠ÂÆö
            FLOOR_BOSS_STAGE_INTERVAL: 8,
            FLOOR_BOSS_BASE_HP: 300,
            FLOOR_BOSS_HP_INCREASE_PERCENT: 0.4,
            FLOOR_BOSS_FLOAT_INTERVAL: 600,
            FLOOR_BOSS_FLOAT_DURATION: 120,
            FLOOR_BOSS_ACTION_INTERVAL: 120,
            FLOOR_BOSS_MOVE_SPEED: 0.5,
            
            // „Éú„ÇπÊîªÊíÉË®≠ÂÆöÔºàÊó¢Â≠òÔºâ
            BOSS_BEAM_HEIGHT: 40,
            BOSS_CEILING_BEAM_WIDTH: 30,
            BOSS_ATTACK_WARNING_FRAMES: 60,
            BOSS_ATTACK_ACTIVE_FRAMES: 30,
            BOSS_BEAM_DAMAGE: 3,
            
            // „Éú„ÇπÊñ∞ÊîªÊíÉË®≠ÂÆö - ÂºæÂπï
            BOSS_BARRAGE_BASE_COUNT: 2,
            BOSS_BARRAGE_SPEED: 5,
            BOSS_BARRAGE_DAMAGE: 1,
            
            // „Éú„ÇπÊñ∞ÊîªÊíÉË®≠ÂÆö - ËøΩÂ∞æÂºæ
            BOSS_HOMING_BASE_COUNT: 2,
            BOSS_HOMING_SPEED: 3,
            BOSS_HOMING_TURN_RATE: 0.03,
            BOSS_HOMING_DAMAGE: 1,
            BOSS_HOMING_LIFE: 300,
            
            // „Éú„ÇπÊñ∞ÊîªÊíÉË®≠ÂÆö - Á™ÅÈÄ≤
            BOSS_CHARGE_SPEED: 10,
            BOSS_CHARGE_DAMAGE: 1,
            BOSS_CHARGE_DISTANCE: 250,
            
            // „Éú„ÇπÊñ∞ÊîªÊíÉË®≠ÂÆö - ÈÄüÂ∫¶‰Ωé‰∏ãÈ≠îÊ≥ï
            BOSS_SLOW_MAGIC_DURATION: 300,
            BOSS_SLOW_MAGIC_RADIUS: 80,
            
            // „Çª„É™„ÉïË°®Á§∫Ë®≠ÂÆö
            SPEECH_BUBBLE_TYPING_SPEED: 3, // „Éï„É¨„Éº„É†„Åî„Å®„Å´1ÊñáÂ≠ó
        };

        // Cached DOM Elements
        const DOM = {};
        
        // Game State
        let canvas, ctx;
        let gameState = 'INIT';
        let frameCount = 0, score = 0, currentStage = 1, previousStage = 1;
        let isFloorBossActive = false, floorBossCount = 0;
        let liteMode = false, isMuted = false;
        
        // Player debuff state
        let playerSlowTimer = 0;
        
        // Images
        const maedaImage = new Image();
        const rangeMaedaImage = new Image();
        const floorBossImage = new Image();
        
        // BGM
        let bgmNormal = null, bgmBoss1 = null, bgmBoss2 = null, currentBGM = null;
        
        // Preloaded sound effects
        const preloadedSounds = {};
        
        // FPS
        let fps = 0, fpsFrameCount = 0, fpsLastTime = performance.now();
        
        // Screen Shake
        const screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
        
        // Input
        const keys = { ArrowLeft: false, ArrowRight: false, Space: false, KeyZ: false, KeyX: false };
        const touchInput = { left: false, right: false, jump: false, punch: false, beam: false };
        let isSpacePressed = false;
        
        // Entities
        const player = {
            x: 100, y: 0, w: 30, h: 60, vx: 0, vy: 0,
            hp: GAME_CONFIG.PLAYER_MAX_HP, facing: 1, beamCooldown: 0,
            invincibility: 0, punching: 0, jumps: 2, maxJumps: 2,
            punchDamage: GAME_CONFIG.PUNCH_DMG, beamMultiplier: 1
        };
        
        let enemies = [], particles = [], damageTexts = [], projectiles = [];
        
        // Speech bubble state
        let speechBubble = {
            active: false,
            text: '',
            displayedText: '',
            x: 0,
            y: 0,
            charIndex: 0,
            frameCounter: 0
        };
        
        // Particle types that need physics
        const PHYSICS_PARTICLES = new Set([
            'pixel', 'punchSpark', 'beamParticle', 'bossDeathParticle', 'explosionParticle',
            'damageParticle', 'bossAppearParticle', 'floatParticle', 'bossTrail',
            'bossBeamParticle', 'bossBeamTrail', 'ceilingBeamParticle', 'ceilingBeamTrail', 'beamSpark',
            'barrageTrail', 'homingTrail', 'chargeTrail', 'slowMagicParticle'
        ]);
        
        const SIMPLE_PARTICLES = new Set([
            'pixel', 'punchSpark', 'beamParticle', 'bossDeathParticle', 'explosionParticle',
            'damageParticle', 'bossAppearParticle', 'floatParticle', 'bossTrail',
            'bossBeamParticle', 'bossBeamTrail', 'ceilingBeamParticle', 'ceilingBeamTrail',
            'barrageTrail', 'homingTrail', 'chargeTrail', 'slowMagicParticle'
        ]);

        // Audio Context
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Utility Functions
        const rand = Math.random;
        const floor = Math.floor;
        const abs = Math.abs;
        const sin = Math.sin;
        const cos = Math.cos;
        const min = Math.min;
        const max = Math.max;
        const sqrt = Math.sqrt;
        const atan2 = Math.atan2;
        const PI = Math.PI;
        const PI2 = PI * 2;

        function cacheDOMElements() {
            const ids = ['scoreBoard', 'hpBoard', 'statusBoard', 'stageCountdown', 'cdText', 'btnBeam',
                        'bossWarning', 'stageNotification', 'damageOverlay', 'slowOverlay', 'fpsCounter', 
                        'saveState', 'debuffIndicator',
                        'loadingScreen', 'errorScreen', 'startScreen', 'gameOverScreen', 'errorMessage',
                        'finalScore', 'startBtn', 'loadBtn', 'saveBtn', 'bgmToggle', 'liteModeCheck'];
            ids.forEach(id => DOM[id] = document.getElementById(id));
        }

        function updateFPS() {
            fpsFrameCount++;
            const now = performance.now();
            const elapsed = now - fpsLastTime;
            if (elapsed >= 1000) {
                fps = Math.round((fpsFrameCount * 1000) / elapsed);
                fpsFrameCount = 0;
                fpsLastTime = now;
                DOM.fpsCounter.textContent = `FPS: ${fps}`;
                DOM.fpsCounter.style.color = fps >= 50 ? '#00ff00' : (fps >= 30 ? '#ffff00' : '#ff0000');
            }
        }

        function triggerScreenShake(intensity, duration) {
            if (liteMode) { intensity *= 0.5; duration = floor(duration * 0.5); }
            screenShake.intensity = intensity;
            screenShake.duration = duration;
        }

        function updateScreenShake() {
            if (screenShake.duration > 0) {
                screenShake.x = (rand() - 0.5) * screenShake.intensity * 2;
                screenShake.y = (rand() - 0.5) * screenShake.intensity * 2;
                screenShake.duration--;
                screenShake.intensity *= 0.95;
            } else {
                screenShake.x = screenShake.y = 0;
            }
        }

        function triggerDamageFlash() {
            DOM.damageOverlay.classList.remove('active');
            void DOM.damageOverlay.offsetWidth;
            DOM.damageOverlay.classList.add('active');
        }

        function loadBGM(url) {
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.preload = 'auto';
                audio.src = url;
                audio.addEventListener('canplaythrough', () => resolve(audio), { once: true });
                audio.addEventListener('error', () => reject(new Error(`BGM„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó: ${url}`)), { once: true });
                audio.load();
            });
        }

        // ÂäπÊûúÈü≥„ÅÆ„Éó„É™„É≠„Éº„Éâ
        function preloadSounds() {
            return new Promise((resolve) => {
                const allSounds = [];
                
                // BEAM sounds
                SOUNDS.BEAM.forEach(url => allSounds.push({ type: 'BEAM', url }));
                // DAMAGE sounds
                SOUNDS.DAMAGE.forEach(url => allSounds.push({ type: 'DAMAGE', url }));
                // BOSS_KILLED sounds
                SOUNDS.BOSS_KILLED.forEach(url => allSounds.push({ type: 'BOSS_KILLED', url }));
                // Single sounds
                allSounds.push({ type: 'BOSS_SUMMON', url: SOUNDS.BOSS_SUMMON });
                allSounds.push({ type: 'GAME_OVER', url: SOUNDS.GAME_OVER });
                allSounds.push({ type: 'STAGE_UP', url: SOUNDS.STAGE_UP });
                
                let loadedCount = 0;
                const totalCount = allSounds.length;
                
                allSounds.forEach(({ type, url }) => {
                    const audio = new Audio();
                    audio.preload = 'auto';
                    audio.src = url;
                    
                    if (!preloadedSounds[type]) {
                        preloadedSounds[type] = [];
                    }
                    
                    audio.addEventListener('canplaythrough', () => {
                        preloadedSounds[type].push(audio);
                        loadedCount++;
                        if (loadedCount >= totalCount) resolve();
                    }, { once: true });
                    
                    audio.addEventListener('error', () => {
                        loadedCount++;
                        if (loadedCount >= totalCount) resolve();
                    }, { once: true });
                    
                    audio.load();
                });
                
                // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÔºà5Áßí„ÅßÂº∑Âà∂ÁöÑ„Å´ÈÄ≤„ÇÄÔºâ
                setTimeout(resolve, 5000);
            });
        }

        function playBGM(type) {
            if (isMuted || gameState !== 'PLAYING') return;
            if (currentBGM) { currentBGM.pause(); currentBGM.currentTime = 0; }
            currentBGM = type === 'normal' ? bgmNormal : (rand() < 0.5 ? bgmBoss1 : bgmBoss2);
            if (currentBGM) {
                currentBGM.loop = true;
                currentBGM.volume = 0.5;
                currentBGM.play().catch(() => {});
            }
        }

        function stopBGM() {
            if (currentBGM) { currentBGM.pause(); currentBGM.currentTime = 0; currentBGM = null; }
        }

        function toggleMute() {
            isMuted = !isMuted;
            DOM.bgmToggle.classList.toggle('muted', isMuted);
            if (isMuted) stopBGM();
            else if (gameState === 'PLAYING') playBGM(isFloorBossActive ? 'boss' : 'normal');
        }

        function showStageNotification(stage) {
            DOM.stageNotification.innerHTML = `STAGE ${stage}<br><span style="font-size:1.5rem">Èõ£ÊòìÂ∫¶‰∏äÊòáÔºÅ</span>`;
            DOM.stageNotification.classList.add('show');
            setTimeout(() => DOM.stageNotification.classList.remove('show'), 2000);
        }

        function updateStageCountdown() {
            if (isFloorBossActive) {
                DOM.stageCountdown.innerHTML = '<span style="color: #ff6666;">‚öîÔ∏è „Éú„ÇπÊà¶‰∏≠ÔºÅ</span>';
                return;
            }
            const framesIn = frameCount % GAME_CONFIG.STAGE_FRAME_DURATION;
            const remaining = GAME_CONFIG.STAGE_FRAME_DURATION - framesIn;
            const secs = Math.ceil(remaining / 60);
            const progress = (framesIn / GAME_CONFIG.STAGE_FRAME_DURATION) * 100;
            const isNextBoss = (currentStage + 1) % GAME_CONFIG.FLOOR_BOSS_STAGE_INTERVAL === 0;
            
            DOM.stageCountdown.innerHTML = isNextBoss
                ? `<span style="color: #ff4444;">‚ö†Ô∏è „Éú„Çπ„Åæ„Åß: ${secs}Áßí</span><div class="countdown-bar"><div class="countdown-fill" style="width: ${100 - progress}%; background: linear-gradient(90deg, #ff0000, #ff6600);"></div></div>`
                : `Ê¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Åæ„Åß: ${secs}Áßí<div class="countdown-bar"><div class="countdown-fill" style="width: ${100 - progress}%;"></div></div>`;
        }

        function playSound(type) {
            // „Éó„É™„É≠„Éº„ÉâÊ∏à„Åø„ÅÆÈü≥Â£∞„Åå„ÅÇ„Çå„Å∞‰ΩøÁî®
            if (preloadedSounds[type] && preloadedSounds[type].length > 0) {
                const sounds = preloadedSounds[type];
                const audio = sounds[floor(rand() * sounds.length)].cloneNode();
                audio.volume = 0.5;
                audio.play().catch(() => {});
                return;
            }
            
            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºöÂæìÊù•„ÅÆÊñπÊ≥ï
            const sounds = SOUNDS[type];
            const src = Array.isArray(sounds) ? sounds[floor(rand() * sounds.length)] : sounds;
            if (!src) return;
            const audio = new Audio(src);
            audio.volume = 0.5;
            audio.play().catch(() => {});
        }

        function addParticle(props) { particles.push(props); }
        
        function addDamageText(x, y, text, life, vy, color) {
            damageTexts.push({ x, y, text, life, vy, color });
        }

        // Âêπ„ÅçÂá∫„ÅóË°®Á§∫ÈñãÂßã
        function showSpeechBubble(e, attackType) {
            const lines = BOSS_ATTACK_LINES[attackType];
            if (!lines || lines.length === 0) return;
            
            const text = lines[floor(rand() * lines.length)];
            speechBubble = {
                active: true,
                text: text,
                displayedText: '',
                x: e.x + e.w / 2,
                y: e.y - 30,
                charIndex: 0,
                frameCounter: 0
            };
        }

        // Âêπ„ÅçÂá∫„Åó„ÅÆÊõ¥Êñ∞
        function updateSpeechBubble() {
            if (!speechBubble.active) return;
            
            speechBubble.frameCounter++;
            
            if (speechBubble.frameCounter >= GAME_CONFIG.SPEECH_BUBBLE_TYPING_SPEED) {
                speechBubble.frameCounter = 0;
                if (speechBubble.charIndex < speechBubble.text.length) {
                    speechBubble.charIndex++;
                    speechBubble.displayedText = speechBubble.text.substring(0, speechBubble.charIndex);
                }
            }
        }

        // Âêπ„ÅçÂá∫„Åó„ÅÆÊèèÁîª
        function drawSpeechBubble() {
            if (!speechBubble.active || !speechBubble.displayedText) return;
            
            const padding = 10;
            const fontSize = 16;
            ctx.font = `bold ${fontSize}px Arial`;
            const textWidth = ctx.measureText(speechBubble.displayedText).width;
            const bubbleWidth = textWidth + padding * 2;
            const bubbleHeight = fontSize + padding * 2;
            
            // „Éú„Çπ„ÅÆ‰ΩçÁΩÆ„Å´ËøΩÂæì
            const boss = enemies.find(e => e.type === 'floor_boss');
            if (boss) {
                speechBubble.x = boss.x + boss.w / 2;
                speechBubble.y = boss.y - 40;
            }
            
            const x = speechBubble.x - bubbleWidth / 2;
            const y = speechBubble.y - bubbleHeight;
            
            // Âêπ„ÅçÂá∫„Åó„ÅÆËÉåÊôØ
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // Ëßí‰∏∏ÂõõËßíÂΩ¢
            const radius = 8;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + bubbleWidth - radius, y);
            ctx.quadraticCurveTo(x + bubbleWidth, y, x + bubbleWidth, y + radius);
            ctx.lineTo(x + bubbleWidth, y + bubbleHeight - radius);
            ctx.quadraticCurveTo(x + bubbleWidth, y + bubbleHeight, x + bubbleWidth - radius, y + bubbleHeight);
            ctx.lineTo(x + radius, y + bubbleHeight);
            ctx.quadraticCurveTo(x, y + bubbleHeight, x, y + bubbleHeight - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Âêπ„ÅçÂá∫„Åó„ÅÆ„Åó„Å£„ÅΩ
            ctx.beginPath();
            ctx.moveTo(speechBubble.x - 8, y + bubbleHeight);
            ctx.lineTo(speechBubble.x, y + bubbleHeight + 12);
            ctx.lineTo(speechBubble.x + 8, y + bubbleHeight);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // „ÉÜ„Ç≠„Çπ„Éà
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.fillText(speechBubble.displayedText, speechBubble.x, y + bubbleHeight - padding);
            ctx.textAlign = 'left';
        }

        // Âêπ„ÅçÂá∫„Åó„ÇíÈñâ„Åò„Çã
        function hideSpeechBubble() {
            speechBubble.active = false;
        }

        // „Éú„Çπ„ÅÆÂºæÂπïÊï∞„ÇíË®àÁÆóÔºàHP„Åå30%Ê∏õ„Çã„Åî„Å®„Å´+1Ôºâ
        function calculateBossBarrageCount(e) {
            const hpPercent = e.hp / e.maxHp;
            const lostPercent = 1 - hpPercent;
            const bonusBullets = floor(lostPercent / 0.3);
            return GAME_CONFIG.BOSS_BARRAGE_BASE_COUNT + bonusBullets;
        }

        // ËøΩÂ∞æÂºæ„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        function hasActiveHomingProjectiles() {
            return projectiles.some(p => p.type === 'homing');
        }

        // Initialization
        window.onload = async () => {
            cacheDOMElements();
            
            try {
                const timestamp = Date.now();
                const resp = await fetch(`${ASSETS.API_URL}?t=${timestamp}`);
                if (!resp.ok) throw new Error(`API Status Error: ${resp.status}`);
                const status = await resp.text();
                if (status.trim().toLowerCase() !== 'allow') throw new Error(`„Ç≤„Éº„É†„ÅÆÂÆüË°å„ÅåË®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Çπ„ÉÜ„Éº„Çø„Çπ: ${status.trim()}`);

                await new Promise((resolve, reject) => {
                    let loaded = 0;
                    const check = () => { if (++loaded === 6) resolve(); };
                    
            const errorMessage = "Êïµ„Ç¢„Çª„ÉÉ„Éà„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü";

            maedaImage.onload = check;
            maedaImage.onerror = () => reject(new Error(errorMessage));
            maedaImage.src = ASSETS.ENEMY_IMG;

            rangeMaedaImage.onload = check;
            rangeMaedaImage.onerror = () => reject(new Error(errorMessage));
            rangeMaedaImage.src = ASSETS.RANGE_ENEMY_IMG;

            floorBossImage.onload = check;
            floorBossImage.onerror = () => reject(new Error(errorMessage));
            floorBossImage.src = ASSETS.FLOOR_BOSS_IMG;

                    loadBGM(BGM.NORMAL).then(a => { bgmNormal = a; check(); }).catch(reject);
                    loadBGM(BGM.BOSS[0]).then(a => { bgmBoss1 = a; check(); }).catch(reject);
                    loadBGM(BGM.BOSS[1]).then(a => { bgmBoss2 = a; check(); }).catch(reject);
                });

                // ÂäπÊûúÈü≥„ÅÆ„Éó„É™„É≠„Éº„Éâ
                await preloadSounds();

                DOM.loadingScreen.classList.add('hidden');
                DOM.startScreen.classList.remove('hidden');
                initGame();
            } catch (err) {
                DOM.loadingScreen.classList.add('hidden');
                DOM.errorScreen.classList.remove('hidden');
                DOM.errorMessage.textContent = `„Ç®„É©„Éº: ${err.message}`;
            }
        };

        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            const resize = () => {
                canvas.width = min(window.innerWidth, 800);
                canvas.height = min(window.innerHeight * 0.75, 500);
                GAME_CONFIG.GROUND_Y = canvas.height - 40;
                player.y = GAME_CONFIG.GROUND_Y - player.h;
            };
            window.addEventListener('resize', resize);
            resize();

            setupInputs();
            DOM.bgmToggle.addEventListener('click', toggleMute);

            const startGame = (loadSave = false) => {
                if (audioContext.state === 'suspended') audioContext.resume();
                liteMode = DOM.liteModeCheck.checked;
                if (loadSave) loadGameData();
                DOM.startScreen.classList.add('hidden');
                gameState = 'PLAYING';
                if (!isMuted) playBGM('normal');
                gameLoop();
            };

            DOM.startBtn.addEventListener('click', () => startGame(false));
            DOM.loadBtn.addEventListener('click', () => {
                if (!_loadCookie('koyamaSave')) {
                    showTempMessage('„Çª„Éº„Éñ„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', '#e53e3e');
                    return;
                }
                startGame(true);
            });
            DOM.saveBtn.addEventListener('click', saveGameManual);

            const raw = _loadCookie('koyamaSave');
            DOM.loadBtn.disabled = !raw;
            updateSaveStateUI(raw ? 'SAVED' : 'NONE');
        }

        function setupInputs() {
            const keyMap = { ArrowLeft: 'ArrowLeft', ArrowRight: 'ArrowRight', Space: 'Space', KeyZ: 'KeyZ', KeyX: 'KeyX' };
            
            window.addEventListener('keydown', e => {
                if (keyMap[e.code]) keys[keyMap[e.code]] = true;
                if (e.code === 'Space' && !isSpacePressed) { isSpacePressed = true; attemptJump(); }
                if (e.code === 'KeyZ') attemptPunch();
                if (e.code === 'KeyX') attemptBeam();
            });
            
            window.addEventListener('keyup', e => {
                if (keyMap[e.code]) keys[keyMap[e.code]] = false;
                if (e.code === 'Space') isSpacePressed = false;
            });

            const bindTouch = (id, key, action) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', e => {
                    e.preventDefault();
                    touchInput[key] = true;
                    el.classList.add('pressed');
                    if (action) action();
                }, { passive: false });
                el.addEventListener('touchend', e => {
                    e.preventDefault();
                    touchInput[key] = false;
                    el.classList.remove('pressed');
                });
            };

            bindTouch('btnLeft', 'left');
            bindTouch('btnRight', 'right');
            bindTouch('btnJump', 'jump', attemptJump);
            bindTouch('btnPunch', 'punch', attemptPunch);
            bindTouch('btnBeam', 'beam', attemptBeam);

            document.addEventListener('touchstart', e => {
                if (e.target.closest('#mobileControls, #gameCanvas')) e.preventDefault();
            }, { passive: false });
        }

        function attemptJump() {
            if (gameState !== 'PLAYING') return;
            const onGround = player.y + player.h >= GAME_CONFIG.GROUND_Y - 1;
            
            if (onGround) {
                player.vy = -GAME_CONFIG.JUMP_FORCE;
                player.jumps = player.maxJumps - 1;
            } else if (player.jumps > 0) {
                player.vy = -GAME_CONFIG.JUMP_FORCE * 0.8;
                player.jumps--;
                const count = liteMode ? 1 : 3;
                for (let i = 0; i < count; i++) {
                    addParticle({ type: 'pixel', x: player.x + player.w/2, y: player.y + player.h,
                        vx: (rand()-0.5)*4, vy: rand() * -3, life: 15, color: '#ffff00' });
                }
            }
        }

        function createPunchEffect(x, y, facing) {
            if (liteMode) {
                addParticle({ type: 'flash', x, y, radius: 20, life: 6, maxLife: 6, color: 'yellow' });
            } else {
                for (let i = 0; i < 4; i++) {
                    const angle = (PI / 3) * (i - 2) + (facing === 1 ? 0 : PI);
                    const speed = 5 + rand() * 3;
                    addParticle({ type: 'punchSpark', x, y, vx: cos(angle) * speed, vy: sin(angle) * speed,
                        life: 10, maxLife: 10, color: '#ffcc00', size: 3 });
                }
                addParticle({ type: 'flash', x, y, radius: 25, life: 6, maxLife: 6, color: 'white' });
            }
        }

        function createBeamEffect(startX, y, dir, width) {
            if (liteMode) {
                addParticle({ type: 'muzzleFlash', x: startX, y, life: 10, maxLife: 10, facing: dir });
                for (let i = 0; i < 5; i++) {
                    addParticle({ type: 'beamParticle', x: startX + dir * (width / 5) * i,
                        y: y + (rand() - 0.5) * 15, vx: dir * 2, vy: (rand() - 0.5) * 2,
                        life: 12, maxLife: 12, color: '#00ffff', size: 3 });
                }
            } else {
                addParticle({ type: 'beamMuzzleFlash', x: startX, y, life: 12, maxLife: 12, facing: dir, size: 50 });
                
                for (let i = 0; i < 20; i++) {
                    const px = dir === 1 ? startX + (width / 20) * i : startX - (width / 20) * i;
                    addParticle({ type: 'beamParticle', x: px, y: y + (rand() - 0.5) * 25,
                        vx: (rand() - 0.5) * 3 + dir * 2, vy: (rand() - 0.5) * 4,
                        life: 18, maxLife: 18, color: rand() > 0.3 ? '#00ffff' : '#ffffff', size: 2 + rand() * 3 });
                }
                
                for (let i = 0; i < 3; i++) {
                    addParticle({ type: 'beamLightning', startX, y, width, direction: dir,
                        life: 10 + i * 3, maxLife: 10 + i * 3, offsetY: (i - 1) * 8, segments: [] });
                }
                
                addParticle({ type: 'beamShockwave', x: startX, y, radius: 5, maxRadius: 40,
                    life: 10, maxLife: 10, facing: dir });
                
                for (let i = 0; i < 8; i++) {
                    const angle = (PI / 4) * (i - 4) + (dir === 1 ? 0 : PI);
                    const speed = 4 + rand() * 4;
                    addParticle({ type: 'beamSpark', x: startX, y, vx: cos(angle) * speed, vy: sin(angle) * speed,
                        life: 12, maxLife: 12, color: '#00ffff', size: 2 + rand() * 2 });
                }
            }
        }

        function generateLightningSegments(startX, width, dir, count) {
            const segs = [];
            const segW = width / count;
            let curY = 0;
            for (let i = 0; i <= count; i++) {
                segs.push({ x: dir === 1 ? startX + segW * i : startX - segW * i, y: curY });
                curY += (rand() - 0.5) * 20;
            }
            return segs;
        }

        function attemptPunch() {
            if (gameState !== 'PLAYING') return;
            player.punching = 10;
            
            const punchRange = 60;
            const punchX = player.facing === 1 ? player.x + player.w : player.x - punchRange;
            const punchCenterX = player.facing === 1 ? player.x + player.w + 15 : player.x - 15;
            const playerCenterY = player.y + player.h / 2;
            let hitAny = false;

            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                if (e.type === 'floor_boss' && e.isFloating) continue;
                
                const offsetX = e.isBoss ? e.w * 0.2 : 0;
                const offsetY = e.isBoss ? e.h * 0.2 : 0;
                const tolerance = e.type === 'floor_boss' ? 100 : 50;

                if (e.x + offsetX < punchX + punchRange && e.x + e.w - offsetX > punchX &&
                    abs((e.y + e.h/2) - playerCenterY) < (tolerance - offsetY)) {
                    hitEnemy(e, player.punchDamage);
                    hitAny = true;
                }
            }

            createPunchEffect(punchCenterX, player.y + 30, player.facing);
            if (hitAny) triggerScreenShake(3, 5);
        }

        function attemptBeam() {
            if (gameState !== 'PLAYING' || player.beamCooldown > 0) return;

            playSound('BEAM');
            player.beamCooldown = GAME_CONFIG.BEAM_COOLDOWN;
            const finalDmg = (GAME_CONFIG.BASE_BEAM_DMG + player.punchDamage * 2) * player.beamMultiplier;

            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                if (e.type === 'floor_boss' && e.isFloating) continue;
                const hit = (player.facing === 1 && e.x > player.x) || (player.facing === -1 && e.x < player.x);
                if (hit) hitEnemy(e, finalDmg);
            }

            if (player.beamMultiplier > 1) {
                addDamageText(player.x, player.y - 40, '„Éì„Éº„É†„ÅÆÂ®ÅÂäõ„ÅåÊàª„Çä„Åæ„Åó„Åü', 60, -1, '#00ffff');
            }
            player.beamMultiplier = 1;

            const beamStartX = player.facing === 1 ? player.x + player.w : player.x;
            const beamWidth = player.facing === 1 ? canvas.width - player.x : player.x;

            addParticle({
                type: 'beam', x: player.facing === 1 ? player.x + player.w : 0,
                y: player.y + player.h/2 - 15, w: player.facing === 1 ? canvas.width - player.x : player.x,
                h: 30, life: 15, maxLife: 15, color: '#00ffff', facing: player.facing
            });

            createBeamEffect(beamStartX, player.y + player.h/2, player.facing, beamWidth);
            triggerScreenShake(4, 8);
        }

        function applyHealEffect() {
            player.hp = min(GAME_CONFIG.PLAYER_MAX_HP, player.hp + GAME_CONFIG.HEAL_AMOUNT);
            addDamageText(player.x, player.y - 10, `+${GAME_CONFIG.HEAL_AMOUNT} HP`, 40, -1, '#00ff00');
        }

        function applyPunchBuff() {
            player.punchDamage += 1;
            addDamageText(player.x, player.y - 20, '„Éë„É≥„ÉÅ„ÅÆÂ®ÅÂäõ„Åå‰∏ä„Åå„Çä„Åæ„Åó„ÅüÔºÅ', 40, -1.5, '#ffaa00');
        }

        function applyBeamBuff() {
            player.beamMultiplier = 2;
            addDamageText(player.x, player.y - 30, 'Ê¨°„ÅÆ„Éì„Éº„É†„ÅÆÂ®ÅÂäõ„ÅåÂÄç„Å´ÔºÅ', 60, -2, '#00ffff');
        }

        function hitEnemy(e, dmg) {
            e.hp -= dmg;
            addDamageText(e.x, e.y, floor(dmg), 30, -2, 'white');

            if (e.hp <= 0) {
                if (e.type === 'heal') {
                    const r = rand();
                    if (r < 0.5) applyHealEffect();
                    else if (r < 0.75) applyPunchBuff();
                    else applyBeamBuff();
                } else if (e.type === 'floor_boss') {
                    playSound('BOSS_KILLED');
                    if (!isMuted) playBGM('normal');
                    score += 500 * (floorBossCount + 1);
                    isFloorBossActive = false;
                    currentStage++;
                    previousStage = currentStage;
                    
                    // „Éú„ÇπÊíÉÁ†¥ÊôÇ„Å´ÈÄüÂ∫¶‰Ωé‰∏ã„ÇíËß£Èô§
                    playerSlowTimer = 0;
                    DOM.slowOverlay.classList.remove('active');
                    
                    // Âêπ„ÅçÂá∫„Åó„ÇíÈùûË°®Á§∫
                    hideSpeechBubble();
                    
                    // „Éú„ÇπÊíÉÁ†¥ÊôÇ„Å´ÊîªÊíÉÂäõ1ÔΩû3„Ç¢„ÉÉ„Éó
                    const atkBonus = floor(rand() * 3) + 1;
                    player.punchDamage += atkBonus;
                    addDamageText(player.x, player.y - 40, `ÊîªÊíÉÂäõ+${atkBonus}ÔºÅ`, 60, -2, '#ff6600');

                    triggerScreenShake(12, 20);
                    const count = liteMode ? 15 : 30;
                    const cx = e.x + e.w/2, cy = e.y + e.h/2;
                    for (let i = 0; i < count; i++) {
                        const angle = (PI2 / count) * i;
                        const speed = 5 + rand() * 10;
                        addParticle({ type: 'bossDeathParticle', x: cx, y: cy,
                            vx: cos(angle) * speed, vy: sin(angle) * speed,
                            life: 40, maxLife: 40, color: `hsl(${280 + rand() * 60}, 100%, 60%)`, size: 4 + rand() * 6 });
                    }
                    const rings = liteMode ? 1 : 3;
                    for (let i = 0; i < rings; i++) {
                        addParticle({ type: 'explosionRing', x: cx, y: cy, radius: 10,
                            maxRadius: 150 + i * 30, life: 20, maxLife: 20, color: 'purple' });
                    }
                } else {
                    score += e.isBoss ? 100 : (e.type === 'range' ? 30 : 10);
                }

                if (e.type !== 'floor_boss') {
                    const pColor = e.type === 'heal' ? 'pink' : (e.type === 'range' ? 'blue' : 'red');
                    const pCount = liteMode ? 3 : 6;
                    const cx = e.x + e.w/2, cy = e.y + e.h/2;
                    for (let i = 0; i < pCount; i++) {
                        addParticle({ type: 'pixel', x: cx, y: cy,
                            vx: (rand()-0.5)*10, vy: (rand()-0.5)*10, life: 20, color: pColor });
                    }
                }
            } else if (e.type !== 'floor_boss') {
                e.x += player.facing * 10;
            }
        }

        function getDifficultyMultiplier(stage) {
            let mult = 1;
            for (let i = 1; i < stage; i++) {
                const boost = GAME_CONFIG.HP_GROWTH_INITIAL_BOOST * Math.exp(-GAME_CONFIG.HP_GROWTH_DECAY * i);
                mult *= GAME_CONFIG.HP_EXPONENTIAL_BASE + boost;
            }
            return mult;
        }

        function spawnEnemy() {
            if (isFloorBossActive) return;
            if (currentStage > 0 && currentStage % GAME_CONFIG.FLOOR_BOSS_STAGE_INTERVAL === 0) { spawnFloorBoss(); return; }
            if (enemies.length >= GAME_CONFIG.MAX_ENEMIES) return;

            const r = rand();
            let type = r < 0.1 ? 'boss' : (r < 0.25 ? 'range' : (r < 0.35 ? 'heal' : 'zako'));

            if ((type === 'boss' || type === 'range') && enemies.some(e => e.isBoss || e.type === 'range')) {
                type = rand() < 0.3 ? 'heal' : 'zako';
            }

            const mult = getDifficultyMultiplier(currentStage);
            let size, hp, speed, img;

            switch (type) {
                case 'boss':
                    size = 100; hp = floor((rand() * 31 + GAME_CONFIG.BASE_BOSS_HP) * mult); speed = 1; img = maedaImage; break;
                case 'heal':
                    size = 40; hp = floor((rand() * 2 + 1) * mult); speed = 3; img = maedaImage; break;
                case 'range':
                    size = 80; hp = floor((rand() * 4 + GAME_CONFIG.BASE_RANGE_HP) * mult); speed = 0.5; img = rangeMaedaImage; break;
                default:
                    size = 40; hp = floor((rand() * 3 + GAME_CONFIG.BASE_ZAKO_HP) * mult); speed = 2; img = maedaImage;
            }

            const side = rand() < 0.5 ? -1 : 1;
            enemies.push({
                x: side === -1 ? -size : canvas.width + size, y: GAME_CONFIG.GROUND_Y - size,
                w: size, h: size, vx: speed, hp, maxHp: hp, isBoss: type === 'boss', type, img,
                moveTimer: 0, currentDirection: side === -1 ? 1 : -1,
                rangeAttackTimer: type === 'range' ? 0 : null,
                spikeState: type === 'range' ? 'idle' : null,
                spikeWarningPos: type === 'range' ? 0 : null
            });
        }

        function spawnFloorBoss() {
            isFloorBossActive = true;
            floorBossCount++;
            enemies = enemies.filter(e => e.type === 'floor_boss');

            playSound('BOSS_SUMMON');
            if (!isMuted) playBGM('boss');
            triggerScreenShake(8, 30);

            addParticle({ type: 'bossAppearFlash', life: 20, maxLife: 20 });

            const count = liteMode ? 4 : 8;
            for (let i = 0; i < count; i++) {
                addParticle({
                    type: 'bossAppearParticle',
                    x: canvas.width - 100 + (rand() - 0.5) * 80,
                    y: GAME_CONFIG.GROUND_Y - 75 + (rand() - 0.5) * 100,
                    vx: (rand() - 0.5) * 5, vy: -rand() * 4,
                    life: 40, maxLife: 40, color: `hsl(${280 + rand() * 40}, 100%, 60%)`, size: 4 + rand() * 4
                });
            }

            DOM.bossWarning.style.display = 'block';
            setTimeout(() => DOM.bossWarning.style.display = 'none', 3000);

            const mult = Math.pow(1 + GAME_CONFIG.FLOOR_BOSS_HP_INCREASE_PERCENT, floorBossCount - 1);
            const maxHp = floor(GAME_CONFIG.FLOOR_BOSS_BASE_HP * mult);
            const size = 150;

            enemies.push({
                type: 'floor_boss', 
                x: canvas.width + 100, 
                y: GAME_CONFIG.GROUND_Y - size,
                w: size, 
                h: size, 
                vx: GAME_CONFIG.FLOOR_BOSS_MOVE_SPEED, 
                hp: maxHp, 
                maxHp, 
                isBoss: true, 
                img: floorBossImage,
                floatTimer: 0, 
                isFloating: false, 
                attackTimer: 0, 
                attackState: 'idle', 
                attackType: null,
                moveTimer: 0, 
                currentDirection: -1, 
                targetX: 0, 
                appearanceFrame: 0,
                // Êñ∞„Åó„ÅÑÊîªÊíÉÁî®„ÅÆ„Çπ„ÉÜ„Éº„Éà
                isCharging: false,
                chargeDistance: 0,
                chargeDirection: 0,
                lastHpThreshold: 1.0  // HPÈñæÂÄ§„ÅÆËøΩË∑°Áî®
            });
        }

        function updateFloorBoss(e) {
            e.appearanceFrame = (e.appearanceFrame || 0) + 1;
            const entryX = canvas.width - 200;

            // ÂÖ•Â†¥‰∏≠
            if (e.x > entryX) {
                e.x -= 2;
                const interval = liteMode ? 6 : 3;
                if (frameCount % interval === 0) {
                    addParticle({ type: 'bossTrail', x: e.x + e.w, y: e.y + e.h/2 + (rand() - 0.5) * e.h,
                        vx: 2, vy: (rand() - 0.5) * 2, life: 15, maxLife: 15, color: 'purple', size: 4 });
                }
                return;
            }

            // Á™ÅÈÄ≤‰∏≠„ÅÆÂá¶ÁêÜ
            if (e.isCharging) {
                e.chargeDistance += GAME_CONFIG.BOSS_CHARGE_SPEED;
                e.x += e.chargeDirection * GAME_CONFIG.BOSS_CHARGE_SPEED;
                
                // Á™ÅÈÄ≤„Éà„É¨„Ç§„É´
                if (frameCount % 2 === 0) {
                    addParticle({ type: 'chargeTrail', x: e.x + e.w/2, y: e.y + e.h/2,
                        vx: -e.chargeDirection * 3, vy: (rand() - 0.5) * 2, life: 15, maxLife: 15,
                        color: '#ff6600', size: 6 + rand() * 4 });
                }
                
                // „Éó„É¨„Ç§„É§„Éº„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆö
                if (player.invincibility <= 0 &&
                    player.x < e.x + e.w - 20 && player.x + player.w > e.x + 20 &&
                    player.y < e.y + e.h - 20 && player.y + player.h > e.y + 20) {
                    handlePlayerDamage(GAME_CONFIG.BOSS_CHARGE_DAMAGE);
                    addDamageText(player.x, player.y, GAME_CONFIG.BOSS_CHARGE_DAMAGE, 30, -2, 'orange');
                    player.vx = e.chargeDirection * 10;
                    player.vy = -5;
                }
                
                // ‰∏ÄÂÆöË∑ùÈõ¢ÈÄ≤„Çì„Å†„Çâ or Â£Å„Å´ÂΩì„Åü„Å£„Åü„ÇâÁ™ÅÈÄ≤ÁµÇ‰∫Ü
                const reachedDistance = e.chargeDistance >= GAME_CONFIG.BOSS_CHARGE_DISTANCE;
                const hitWall = e.x <= 0 || e.x + e.w >= canvas.width;
                
                if (reachedDistance || hitWall) {
                    e.isCharging = false;
                    e.x = max(0, min(canvas.width - e.w, e.x));
                    triggerScreenShake(4, 8);
                    
                    // ÂÅúÊ≠¢„Ç®„Éï„Çß„ÇØ„Éà
                    const cnt = liteMode ? 3 : 6;
                    for (let i = 0; i < cnt; i++) {
                        addParticle({ type: 'pixel', x: e.x + e.w/2, 
                            y: e.y + rand() * e.h, vx: -e.chargeDirection * (2 + rand() * 3),
                            vy: (rand() - 0.5) * 4, life: 15, color: '#ff6600' });
                    }
                }
                return;
            }

            // ÊµÆÈÅä„É≠„Ç∏„ÉÉ„ÇØ
            e.floatTimer++;
            const floatCycle = GAME_CONFIG.FLOOR_BOSS_FLOAT_INTERVAL;
            const floatDur = GAME_CONFIG.FLOOR_BOSS_FLOAT_DURATION;

            if (e.floatTimer % floatCycle > (floatCycle - floatDur)) {
                if (!e.isFloating) {
                    e.isFloating = true;
                    e.targetY = 50;
                    const cnt = liteMode ? 3 : 6;
                    for (let i = 0; i < cnt; i++) {
                        addParticle({ type: 'floatParticle', x: e.x + e.w/2 + (rand() - 0.5) * e.w, y: e.y + e.h,
                            vx: (rand() - 0.5) * 2, vy: rand() * 2 + 1, life: 20, maxLife: 20,
                            color: 'rgba(150, 0, 255, 0.8)', size: 3 });
                    }
                }
                e.y += (e.targetY - e.y) * 0.1;
                
                // È£õË°å‰∏≠„Å´ÂºæÂπï„ÇíÁô∫Â∞Ñ
                if (frameCount % 90 === 0) {
                    fireBarrage(e);
                }
            } else {
                if (e.isFloating) { 
                    e.isFloating = false; 
                    e.targetY = GAME_CONFIG.GROUND_Y - e.h; 
                }
                const groundY = GAME_CONFIG.GROUND_Y - e.h;
                if (abs(e.y - groundY) > 1) e.y += (groundY - e.y) * 0.1;
                else e.y = groundY;
            }

            // ÁßªÂãï„É≠„Ç∏„ÉÉ„ÇØÔºàÊµÆÈÅä‰∏≠„Åß„Å™„Åè„ÄÅÁ™ÅÈÄ≤‰∏≠„Åß„ÇÇ„Å™„ÅÑÂ†¥ÂêàÔºâ
            if (!e.isFloating && !e.isCharging) {
                const bossCenter = e.x + e.w / 2;
                const playerCenter = player.x + player.w / 2;
                if (abs(bossCenter - playerCenter) > 50) {
                    e.x += GAME_CONFIG.FLOOR_BOSS_MOVE_SPEED * (bossCenter < playerCenter ? 1 : -1);
                    e.x = max(0, min(canvas.width - e.w, e.x));
                }
            }

            // ÊµÆÈÅä‰∏≠„ÅØÊîªÊíÉ„Åó„Å™„ÅÑÔºàÂºæÂπï„ÅØÂà•„ÅßÂá¶ÁêÜÔºâ
            if (e.isFloating) return;

            // ÊîªÊíÉ„É≠„Ç∏„ÉÉ„ÇØ
            e.attackTimer++;

            if (e.attackState === 'idle') {
                if (e.attackTimer > GAME_CONFIG.FLOOR_BOSS_ACTION_INTERVAL) {
                    e.attackState = 'warning';
                    e.attackTimer = 0;
                    
                    // ÊîªÊíÉ„Çø„Ç§„Éó„Çí„É©„É≥„ÉÄ„É†„Å´ÈÅ∏ÊäûÔºàËøΩÂ∞æÂºæ„ÅØÊó¢Â≠ò„ÅÆÂºæ„Åå„Å™„Åë„Çå„Å∞ÈÅ∏ÊäûÂèØËÉΩÔºâ
                    let availableAttacks = ['beam', 'area', 'ceilingBeam', 'charge', 'slowMagic', 'barrage'];
                    
                    // ËøΩÂ∞æÂºæ„ÅåÂ≠òÂú®„Åó„Å™„Åë„Çå„Å∞ËøΩÂ∞æÂºæ„ÇÇÈÅ∏ÊäûËÇ¢„Å´ËøΩÂä†
                    if (!hasActiveHomingProjectiles()) {
                        availableAttacks.push('homing');
                    }
                    
                    const r = rand();
                    const attackIndex = floor(r * availableAttacks.length);
                    e.attackType = availableAttacks[attackIndex];
                    
                    // „Çª„É™„ÉïË°®Á§∫
                    showSpeechBubble(e, e.attackType);
                    
                    if (e.attackType === 'area' || e.attackType === 'ceilingBeam' || e.attackType === 'slowMagic') {
                        e.targetX = player.x + player.w / 2;
                    }
                    triggerScreenShake(2, 20);
                }
            } else if (e.attackState === 'warning') {
                const interval = liteMode ? 10 : 5;
                if (frameCount % interval === 0) {
                    let tX, tY, col;
                    
                    switch (e.attackType) {
                        case 'beam':
                            tX = e.x; tY = GAME_CONFIG.GROUND_Y - 20; col = 'purple'; break;
                        case 'area':
                            tX = e.targetX; tY = GAME_CONFIG.GROUND_Y - 20; col = 'orange'; break;
                        case 'ceilingBeam':
                            tX = e.targetX; tY = 0; col = 'red'; break;
                        case 'homing':
                            tX = e.x + e.w/2; tY = e.y + e.h/2; col = '#ff00ff'; break;
                        case 'charge':
                            tX = e.x + e.w/2; tY = e.y + e.h/2; col = '#ff6600'; break;
                        case 'slowMagic':
                            tX = e.targetX; tY = GAME_CONFIG.GROUND_Y - 40; col = '#00aaff'; break;
                        case 'barrage':
                            tX = e.x + e.w/2; tY = e.y + e.h/2; col = '#ff0066'; break;
                        default:
                            tX = e.x; tY = GAME_CONFIG.GROUND_Y - 20; col = 'purple';
                    }
                    
                    addParticle({ type: 'chargeParticle', x: tX + (rand() - 0.5) * 80, y: tY + (rand() - 0.5) * 40,
                        targetX: tX, targetY: tY, life: 15, maxLife: 15, color: col });
                }

                if (e.attackTimer > GAME_CONFIG.BOSS_ATTACK_WARNING_FRAMES) {
                    e.attackState = 'active';
                    e.attackTimer = 0;
                    triggerScreenShake(6, 12);
                    
                    // Âêπ„ÅçÂá∫„Åó„ÇíÈùûË°®Á§∫
                    hideSpeechBubble();

                    // ÊîªÊíÉÂÆüË°å
                    executeFloorBossAttack(e);
                }
            } else if (e.attackState === 'active' && e.attackTimer > GAME_CONFIG.BOSS_ATTACK_ACTIVE_FRAMES) {
                e.attackState = 'idle';
                e.attackTimer = 0;
            }
        }

        // ÂºæÂπïÁô∫Â∞ÑÔºà„Éó„É¨„Ç§„É§„Éº„Åå„ÅÑ„ÇãÊñπÂêë„Å´Âêë„Åã„Å£„Å¶Áô∫Â∞ÑÔºâ
        function fireBarrage(e) {
            const barrageCount = calculateBossBarrageCount(e);
            const centerX = e.x + e.w / 2;
            const centerY = e.y + e.h / 2;
            const playerCenterX = player.x + player.w / 2;
            const playerCenterY = player.y + player.h / 2;
            
            // „Éó„É¨„Ç§„É§„ÉºÊñπÂêë„Å∏„ÅÆÂü∫Ê∫ñËßíÂ∫¶ÔºàÁô∫Â∞ÑÊôÇÁÇπ„ÅßÂõ∫ÂÆöÔºâ
            const baseAngle = atan2(playerCenterY - centerY, playerCenterX - centerX);
            
            // Âºæ„ÅÆÈñìÈöîÔºàÂ∞ë„Åó„Åö„Çâ„Åó„Å¶Áô∫Â∞ÑÔºâ
            const spreadAngle = PI / 8; // 22.5Â∫¶„ÅÆÊâáÔºàÁã≠„ÇÅÔºâ
            
            for (let i = 0; i < barrageCount; i++) {
                // Âºæ„ÅåË§áÊï∞„ÅÆÂ†¥Âêà„ÅØÂ∞ë„Åó„Å†„ÅëËßíÂ∫¶„Çí„Åö„Çâ„Åô
                const angleOffset = barrageCount > 1 
                    ? (i / (barrageCount - 1) - 0.5) * spreadAngle 
                    : 0;
                const angle = baseAngle + angleOffset;
                
                // Â∞ë„ÅóÈÅÖÂª∂„Çí‰ªò„Åë„Å¶Áô∫Â∞ÑÔºàÊôÇÈñìÂ∑ÆÊîªÊíÉÔºâ
                const delay = i * 5;
                
                setTimeout(() => {
                    if (gameState !== 'PLAYING') return;
                    projectiles.push({
                        type: 'barrage',
                        x: centerX,
                        y: centerY,
                        w: 12,
                        h: 12,
                        vx: cos(angle) * GAME_CONFIG.BOSS_BARRAGE_SPEED,
                        vy: sin(angle) * GAME_CONFIG.BOSS_BARRAGE_SPEED,
                        damage: GAME_CONFIG.BOSS_BARRAGE_DAMAGE,
                        life: 180,
                        color: '#ff0066'
                    });
                }, delay * 16); // Á¥Ñ16msÔºà1„Éï„É¨„Éº„É†Ôºâ„Åö„Å§ÈÅÖÂª∂
            }
            
            // Áô∫Â∞Ñ„Ç®„Éï„Çß„ÇØ„Éà
            const cnt = liteMode ? 3 : 6;
            for (let i = 0; i < cnt; i++) {
                addParticle({ type: 'pixel', x: centerX, y: centerY,
                    vx: (rand() - 0.5) * 6, vy: (rand() - 0.5) * 6, life: 15, color: '#ff0066' });
            }
        }

        // „Éú„ÇπÊîªÊíÉÂÆüË°å
        function executeFloorBossAttack(e) {
            switch (e.attackType) {
                case 'beam':
                    projectiles.push({ type: 'bossBeam', x: canvas.width, y: GAME_CONFIG.GROUND_Y - GAME_CONFIG.BOSS_BEAM_HEIGHT / 2,
                        w: canvas.width, h: GAME_CONFIG.BOSS_BEAM_HEIGHT, vx: -30, vy: 0, damage: GAME_CONFIG.BOSS_BEAM_DAMAGE,
                        life: canvas.width / 30 + 10, color: 'purple', spawnTime: frameCount });
                    const beamCnt = liteMode ? 5 : 12;
                    for (let i = 0; i < beamCnt; i++) {
                        addParticle({ type: 'bossBeamParticle', x: canvas.width,
                            y: GAME_CONFIG.GROUND_Y - GAME_CONFIG.BOSS_BEAM_HEIGHT / 2 + (rand() - 0.5) * 50,
                            vx: -12 - rand() * 8, vy: (rand() - 0.5) * 4, life: 25, maxLife: 25,
                            color: `hsl(${280 + rand() * 40}, 100%, 60%)`, size: 3 + rand() * 3 });
                    }
                    break;
                    
                case 'area':
                    projectiles.push({ type: 'explosion', x: e.targetX, y: GAME_CONFIG.GROUND_Y, w: 100, h: 150,
                        damage: 4, life: GAME_CONFIG.BOSS_ATTACK_ACTIVE_FRAMES, color: 'orange', spawnTime: frameCount });
                    const areaCnt = liteMode ? 8 : 15;
                    for (let i = 0; i < areaCnt; i++) {
                        const angle = rand() * PI;
                        const speed = 3 + rand() * 6;
                        addParticle({ type: 'explosionParticle', x: e.targetX, y: GAME_CONFIG.GROUND_Y - 20,
                            vx: cos(angle) * speed * (rand() > 0.5 ? 1 : -1), vy: -sin(angle) * speed,
                            life: 25, maxLife: 25, color: `hsl(${30 + rand() * 20}, 100%, 60%)`, size: 3 + rand() * 4 });
                    }
                    break;
                    
                case 'ceilingBeam':
                    projectiles.push({ type: 'ceilingBeam', x: e.targetX - GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH / 2,
                        y: 0, w: GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH, h: GAME_CONFIG.GROUND_Y, vx: 0, vy: 0,
                        damage: GAME_CONFIG.BOSS_BEAM_DAMAGE, life: GAME_CONFIG.BOSS_ATTACK_ACTIVE_FRAMES, color: 'red', spawnTime: frameCount });
                    const ceilCnt = liteMode ? 5 : 10;
                    for (let i = 0; i < ceilCnt; i++) {
                        addParticle({ type: 'ceilingBeamParticle', x: e.targetX + (rand() - 0.5) * 30,
                            y: rand() * GAME_CONFIG.GROUND_Y, vx: (rand() - 0.5) * 2, vy: 4 + rand() * 4,
                            life: 15, maxLife: 15, color: `hsl(${rand() * 30}, 100%, 60%)`, size: 2 + rand() * 3 });
                    }
                    break;
                    
                case 'homing':
                    // ËøΩÂ∞æÂºæ„ÇíÁô∫Â∞Ñ
                    const homingCount = GAME_CONFIG.BOSS_HOMING_BASE_COUNT + floor((1 - e.hp / e.maxHp) / 0.3);
                    for (let i = 0; i < homingCount; i++) {
                        const angle = (PI2 / homingCount) * i - PI / 2;
                        projectiles.push({
                            type: 'homing',
                            x: e.x + e.w / 2,
                            y: e.y + e.h / 2,
                            w: 15,
                            h: 15,
                            vx: cos(angle) * 2,
                            vy: sin(angle) * 2,
                            damage: GAME_CONFIG.BOSS_HOMING_DAMAGE,
                            life: GAME_CONFIG.BOSS_HOMING_LIFE,
                            color: '#ff00ff'
                        });
                    }
                    addDamageText(e.x + e.w/2, e.y, 'ËøΩÂ∞æÂºæÔºÅ', 40, -2, '#ff00ff');
                    break;
                    
                case 'charge':
                    // Á™ÅÈÄ≤ÈñãÂßã
                    e.isCharging = true;
                    e.chargeDistance = 0;
                    e.chargeDirection = player.x + player.w/2 > e.x + e.w/2 ? 1 : -1;
                    addDamageText(e.x + e.w/2, e.y, 'Á™ÅÈÄ≤ÔºÅ', 40, -2, '#ff6600');
                    triggerScreenShake(3, 8);
                    break;
                    
                case 'slowMagic':
                    // ÈÄüÂ∫¶‰Ωé‰∏ãÈ≠îÊ≥ï
                    projectiles.push({
                        type: 'slowMagic',
                        x: e.targetX,
                        y: GAME_CONFIG.GROUND_Y - 60,
                        w: GAME_CONFIG.BOSS_SLOW_MAGIC_RADIUS * 2,
                        h: GAME_CONFIG.BOSS_SLOW_MAGIC_RADIUS * 2,
                        damage: 0,
                        life: 90,
                        maxLife: 90,
                        color: '#00aaff'
                    });
                    addDamageText(e.x + e.w/2, e.y, 'ÈÄüÂ∫¶‰Ωé‰∏ãÈ≠îÊ≥ïÔºÅ', 40, -2, '#00aaff');
                    break;
                    
                case 'barrage':
                    // Âú∞‰∏ä„Åß„ÅÆÂºæÂπïÁô∫Â∞Ñ
                    fireBarrage(e);
                    addDamageText(e.x + e.w/2, e.y, 'ÂºæÂπïÔºÅ', 40, -2, '#ff0066');
                    break;
            }
        }

        function handleRangedAttacks(e) {
            if (e.type !== 'range') return;
            e.rangeAttackTimer = (e.rangeAttackTimer + 1) % 3600;

            if (e.rangeAttackTimer % 180 === 0) {
                const startX = e.x + e.w / 2, startY = e.y + e.h * 0.7;
                const dir = player.x + player.w / 2 > startX ? 1 : -1;
                projectiles.push({ type: 'shortBeam', x: startX, y: startY, w: 15, h: 8,
                    vx: dir * 6, vy: 0, damage: 1, color: 'rgba(255, 165, 0, 0.9)', life: 180 });
                const cnt = liteMode ? 2 : 4;
                for (let i = 0; i < cnt; i++) {
                    addParticle({ type: 'pixel', x: startX, y: startY, vx: dir * (2 + rand() * 2),
                        vy: (rand() - 0.5) * 3, life: 8, color: 'orange' });
                }
            }

            if (e.rangeAttackTimer % 300 === 0) {
                e.spikeState = 'warning';
                e.spikeWarningPos = player.x + player.w / 2;
                projectiles.push({ type: 'spike', x: e.spikeWarningPos, y: GAME_CONFIG.GROUND_Y,
                    w: 40, h: 0, damage: 2, state: 'warning', life: 60, maxLife: 60, owner: e });
            }
        }

        function handlePlayerDamage(damage) {
            if (player.invincibility > 0) return;
            player.hp -= damage;
            player.invincibility = GAME_CONFIG.INVINCIBILITY_FRAMES;
            playSound('DAMAGE');
            triggerDamageFlash();
            triggerScreenShake(6, 10);

            const cnt = liteMode ? 3 : 6;
            const cx = player.x + player.w / 2, cy = player.y + player.h / 2;
            for (let i = 0; i < cnt; i++) {
                addParticle({ type: 'damageParticle', x: cx, y: cy, vx: (rand() - 0.5) * 8, vy: (rand() - 0.5) * 8,
                    life: 15, maxLife: 15, color: 'red', size: 3 + rand() * 3 });
            }

            if (player.hp <= 0) {
                playSound('GAME_OVER');
                stopBGM();
                gameState = 'GAMEOVER';
                DOM.finalScore.textContent = score;
                DOM.gameOverScreen.classList.remove('hidden');
            }
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.life--;

                if (p.type === 'bossBeam') {
                    p.x += p.vx;
                    const interval = liteMode ? 4 : 2;
                    if (frameCount % interval === 0) {
                        addParticle({ type: 'bossBeamTrail', x: p.x, y: p.y + (rand() - 0.5) * p.h,
                            vx: -2, vy: (rand() - 0.5) * 2, life: 10, maxLife: 10, color: 'purple', size: 2 });
                    }
                    if (player.invincibility <= 0) {
                        const top = p.y - p.h / 2, bot = p.y + p.h / 2;
                        if (player.x < p.x && player.x + player.w > p.x + p.vx && player.y + player.h > top && player.y < bot) {
                            handlePlayerDamage(p.damage);
                            addDamageText(player.x, player.y, p.damage, 30, -2, 'red');
                        }
                    }
                    if (p.x + p.h < 0) p.life = 0;
                } else if (p.type === 'explosion') {
                    if (player.invincibility <= 0 && player.x < p.x + p.w/2 && player.x + player.w > p.x - p.w/2 &&
                        player.y + player.h > GAME_CONFIG.GROUND_Y - p.h) {
                        handlePlayerDamage(p.damage);
                        addDamageText(player.x, player.y, p.damage, 30, -2, 'red');
                    }
                } else if (p.type === 'ceilingBeam') {
                    const interval = liteMode ? 4 : 2;
                    if (frameCount % interval === 0) {
                        addParticle({ type: 'ceilingBeamTrail', x: p.x + p.w/2 + (rand() - 0.5) * 15,
                            y: rand() * p.h, vx: (rand() - 0.5) * 1.5, vy: 2, life: 8, maxLife: 8, color: 'red', size: 2 });
                    }
                    if (player.invincibility <= 0 && player.x < p.x + p.w && player.x + player.w > p.x &&
                        player.y < p.y + p.h && player.y + player.h > p.y) {
                        handlePlayerDamage(p.damage);
                        addDamageText(player.x, player.y, p.damage, 30, -2, 'red');
                    }
                } else if (p.type === 'shortBeam') {
                    p.x += p.vx;
                    const interval = liteMode ? 6 : 3;
                    if (frameCount % interval === 0) {
                        addParticle({ type: 'pixel', x: p.x, y: p.y, vx: -p.vx * 0.2, vy: (rand() - 0.5) * 1.5, life: 8, color: 'yellow' });
                    }
                    if (player.invincibility <= 0 && player.x < p.x + p.w && player.x + player.w > p.x &&
                        player.y < p.y + p.h && player.y + player.h > p.y) {
                        handlePlayerDamage(p.damage);
                        addDamageText(player.x, player.y, p.damage, 30, -2, 'red');
                        p.life = 0;
                    }
                    if (p.x < 0 || p.x > canvas.width) p.life = 0;
                } else if (p.type === 'spike') {
                    if (p.state === 'warning') {
                        if (p.life <= 0) {
                            p.state = 'active';
                            p.life = 30;
                            p.h = 50;
                            const cnt = liteMode ? 3 : 6;
                            for (let j = 0; j < cnt; j++) {
                                addParticle({ type: 'pixel', x: p.x + (rand() - 0.5) * 25, y: GAME_CONFIG.GROUND_Y - 10,
                                    vx: (rand() - 0.5) * 5, vy: -rand() * 4 - 2, life: 12, color: '#654321' });
                            }
                        }
                    } else if (p.state === 'active' && player.invincibility <= 0 &&
                        player.x < p.x + p.w / 2 && player.x + player.w > p.x - p.w / 2 && player.y + player.h > p.y - p.h) {
                        handlePlayerDamage(p.damage);
                        addDamageText(player.x, player.y, p.damage, 30, -2, 'red');
                    }
                } else if (p.type === 'barrage') {
                    // ÂºæÂπïÂºæ„ÅÆÊõ¥Êñ∞
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // „Éà„É¨„Ç§„É´
                    if (frameCount % 3 === 0) {
                        addParticle({ type: 'barrageTrail', x: p.x, y: p.y,
                            vx: 0, vy: 0, life: 10, maxLife: 10, color: '#ff0066', size: 4 });
                    }
                    
                    // „Éó„É¨„Ç§„É§„Éº„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆö
                    if (player.invincibility <= 0 &&
                        player.x < p.x + p.w/2 && player.x + player.w > p.x - p.w/2 &&
                        player.y < p.y + p.h/2 && player.y + player.h > p.y - p.h/2) {
                        handlePlayerDamage(p.damage);
                        addDamageText(player.x, player.y, p.damage, 30, -2, '#ff0066');
                        p.life = 0;
                    }
                    
                    // ÁîªÈù¢Â§ñ„ÅßÊ∂àÊªÖ
                    if (p.x < -20 || p.x > canvas.width + 20 || p.y < -20 || p.y > canvas.height + 20) {
                        p.life = 0;
                    }
                } else if (p.type === 'homing') {
                    // ËøΩÂ∞æÂºæ„ÅÆÊõ¥Êñ∞
                    const playerCenterX = player.x + player.w / 2;
                    const playerCenterY = player.y + player.h / 2;
                    const dx = playerCenterX - p.x;
                    const dy = playerCenterY - p.y;
                    const targetAngle = atan2(dy, dx);
                    const currentAngle = atan2(p.vy, p.vx);
                    
                    // ËßíÂ∫¶„ÇíÂæê„ÄÖ„Å´Ë™øÊï¥
                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > PI) angleDiff -= PI2;
                    while (angleDiff < -PI) angleDiff += PI2;
                    
                    const newAngle = currentAngle + angleDiff * GAME_CONFIG.BOSS_HOMING_TURN_RATE;
                    p.vx = cos(newAngle) * GAME_CONFIG.BOSS_HOMING_SPEED;
                    p.vy = sin(newAngle) * GAME_CONFIG.BOSS_HOMING_SPEED;
                    
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // „Éà„É¨„Ç§„É´
                    if (frameCount % 2 === 0) {
                        addParticle({ type: 'homingTrail', x: p.x, y: p.y,
                            vx: -p.vx * 0.3, vy: -p.vy * 0.3, life: 15, maxLife: 15, color: '#ff00ff', size: 5 });
                    }
                    
                    // „Éó„É¨„Ç§„É§„Éº„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆö
                    if (player.invincibility <= 0 &&
                        player.x < p.x + p.w/2 && player.x + player.w > p.x - p.w/2 &&
                        player.y < p.y + p.h/2 && player.y + player.h > p.y - p.h/2) {
                        handlePlayerDamage(p.damage);
                        addDamageText(player.x, player.y, p.damage, 30, -2, '#ff00ff');
                        p.life = 0;
                        
                        // ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà
                        const cnt = liteMode ? 4 : 8;
                        for (let j = 0; j < cnt; j++) {
                            addParticle({ type: 'pixel', x: p.x, y: p.y,
                                vx: (rand() - 0.5) * 8, vy: (rand() - 0.5) * 8, life: 15, color: '#ff00ff' });
                        }
                    }
                    
                    // ÁîªÈù¢Â§ñ„ÅßÊ∂àÊªÖ
                    if (p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) {
                        p.life = 0;
                    }
                } else if (p.type === 'slowMagic') {
                    // ÈÄüÂ∫¶‰Ωé‰∏ãÈ≠îÊ≥ï„ÅÆÊõ¥Êñ∞
                    const radius = GAME_CONFIG.BOSS_SLOW_MAGIC_RADIUS;
                    const playerCenterX = player.x + player.w / 2;
                    const playerCenterY = player.y + player.h / 2;
                    const dx = playerCenterX - p.x;
                    const dy = playerCenterY - (p.y + radius);
                    const dist = sqrt(dx * dx + dy * dy);
                    
                    // „Éó„É¨„Ç§„É§„Éº„ÅåÁØÑÂõ≤ÂÜÖ„Å´„ÅÑ„Åü„ÇâÈÄüÂ∫¶‰Ωé‰∏ã
                    if (dist < radius) {
                        playerSlowTimer = GAME_CONFIG.BOSS_SLOW_MAGIC_DURATION;
                        DOM.slowOverlay.classList.add('active');
                        addDamageText(player.x, player.y - 20, 'ÈÄüÂ∫¶‰Ωé‰∏ãÔºÅ', 30, -1, '#00aaff');
                        p.life = 0;  // ÂΩì„Åü„Å£„Åü„ÇâÊ∂à„Åà„Çã
                    }
                    
                    // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´„Ç®„Éï„Çß„ÇØ„Éà
                    if (frameCount % 5 === 0) {
                        const angle = rand() * PI2;
                        const r = rand() * radius;
                        addParticle({ type: 'slowMagicParticle', 
                            x: p.x + cos(angle) * r, 
                            y: p.y + radius + sin(angle) * r * 0.5,
                            vx: (rand() - 0.5) * 1, vy: -rand() * 2 - 1, life: 20, maxLife: 20, 
                            color: '#00aaff', size: 3 });
                    }
                }

                if (p.life <= 0) projectiles.splice(i, 1);
            }
        }

        function update() {
            if (gameState === 'GAMEOVER') return;

            frameCount++;
            updateScreenShake();
            updateFPS();
            updateSpeechBubble();

            if (!isFloorBossActive && frameCount % GAME_CONFIG.STAGE_FRAME_DURATION === 0) currentStage++;

            if (currentStage > previousStage) {
                showStageNotification(currentStage);
                previousStage = currentStage;
            }

            updateStageCountdown();

            // ÈÄüÂ∫¶‰Ωé‰∏ã„Çø„Ç§„Éû„Éº„ÅÆÊõ¥Êñ∞
            if (playerSlowTimer > 0) {
                playerSlowTimer--;
                if (playerSlowTimer <= 0) {
                    DOM.slowOverlay.classList.remove('active');
                }
            }
            
            // „Éá„Éê„ÉïË°®Á§∫„ÅÆÊõ¥Êñ∞
            if (playerSlowTimer > 0) {
                DOM.debuffIndicator.innerHTML = `üê¢ ÈÄüÂ∫¶‰Ωé‰∏ã: ${Math.ceil(playerSlowTimer / 60)}Áßí`;
            } else {
                DOM.debuffIndicator.innerHTML = '';
            }

            // Player movementÔºàÈÄüÂ∫¶‰Ωé‰∏ãËÄÉÊÖÆÔºâ
            const currentSpeed = playerSlowTimer > 0 ? GAME_CONFIG.PLAYER_SLOW_SPEED : GAME_CONFIG.PLAYER_SPEED;
            
            if (keys.ArrowLeft || touchInput.left) { player.vx = -currentSpeed; player.facing = -1; }
            else if (keys.ArrowRight || touchInput.right) { player.vx = currentSpeed; player.facing = 1; }
            else player.vx = 0;

            player.vy += GAME_CONFIG.GRAVITY;
            player.x += player.vx;
            player.y += player.vy;
            player.x = max(0, min(canvas.width - player.w, player.x));

            if (player.y + player.h > GAME_CONFIG.GROUND_Y) {
                player.y = GAME_CONFIG.GROUND_Y - player.h;
                player.vy = 0;
                player.jumps = player.maxJumps;
            }

            if (player.beamCooldown > 0) player.beamCooldown--;
            if (player.punching > 0) player.punching--;
            if (player.invincibility > 0) player.invincibility--;

            // Spawn enemies
            if (frameCount % GAME_CONFIG.SPAWN_RATE === 0) spawnEnemy();
            if (!isFloorBossActive && frameCount % 600 === 0 && GAME_CONFIG.SPAWN_RATE > 30) GAME_CONFIG.SPAWN_RATE--;

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];

                if (e.type === 'floor_boss') {
                    updateFloorBoss(e);
                } else {
                    handleRangedAttacks(e);
                    e.moveTimer++;
                    const seekLimit = e.isBoss ? GAME_CONFIG.ENEMY_SEEK_DURATION_BOSS : GAME_CONFIG.ENEMY_SEEK_DURATION_ZAKO;

                    if (e.type === 'range') {
                        if (abs(e.x - player.x) > 300) {
                            e.currentDirection = e.x + e.w/2 < player.x + player.w/2 ? 1 : -1;
                            e.x += e.vx * e.currentDirection;
                        }
                    } else if (e.moveTimer < seekLimit) {
                        e.currentDirection = e.x + e.w/2 < player.x + player.w/2 ? 1 : -1;
                        e.x += e.vx * e.currentDirection;
                    } else {
                        if (e.x <= 0) e.currentDirection = 1;
                        else if (e.x + e.w >= canvas.width) e.currentDirection = -1;
                        e.x += e.vx * e.currentDirection;
                        e.x = max(0, min(canvas.width - e.w, e.x));
                    }
                }

                // CollisionÔºàÁ™ÅÈÄ≤‰∏≠„ÅÆ„Éú„Çπ„ÅØÂà•Âá¶ÁêÜÔºâ
                if (!(e.type === 'floor_boss' && (e.isFloating || e.isCharging))) {
                    const ox = e.isBoss ? e.w * 0.2 : 10;
                    const oy = e.isBoss ? e.h * 0.2 : 0;

                    if (player.invincibility <= 0 && player.x < e.x + e.w - ox && player.x + player.w > e.x + ox &&
                        player.y < e.y + e.h - oy && player.y + player.h > e.y + oy) {
                        handlePlayerDamage(e.type === 'floor_boss' ? 2 : 1);
                        player.vy = -5;
                        player.vx = player.x < e.x ? -10 : 10;
                    }
                }

                if (e.hp <= 0) enemies.splice(i, 1);
            }

            updateProjectiles();

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life--;

                if (PHYSICS_PARTICLES.has(p.type)) {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.vy !== undefined && p.type !== 'floatParticle' && p.type !== 'slowMagicParticle') p.vy += 0.1;
                }

                if (p.type === 'shockwave' || p.type === 'explosionRing' || p.type === 'beamShockwave') {
                    p.radius += (p.maxRadius - p.radius) * 0.25;
                }

                if (p.type === 'chargeParticle') {
                    p.x += (p.targetX - p.x) * 0.15;
                    p.y += (p.targetY - p.y) * 0.15;
                }

                if (p.type === 'beamLightning' && p.segments) {
                    for (const seg of p.segments) seg.y += (rand() - 0.5) * 3;
                }

                if (p.life <= 0) particles.splice(i, 1);
            }

            // Update damage texts
            for (let i = damageTexts.length - 1; i >= 0; i--) {
                const t = damageTexts[i];
                t.life--;
                t.y += t.vy;
                if (t.life <= 0) damageTexts.splice(i, 1);
            }
        }

        function draw() {
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);

            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);

            if (isFloorBossActive) {
                ctx.fillStyle = 'rgba(50, 0, 80, 0.3)';
                ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);
                if (!liteMode) {
                    const alpha = 0.08 + sin(frameCount * 0.05) * 0.04;
                    const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width * 0.7);
                    grad.addColorStop(0, 'transparent');
                    grad.addColorStop(1, `rgba(100, 0, 150, ${alpha})`);
                    ctx.fillStyle = grad;
                    ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);
                }
            }

            ctx.fillStyle = '#654321';
            ctx.fillRect(-10, GAME_CONFIG.GROUND_Y, canvas.width + 20, canvas.height - GAME_CONFIG.GROUND_Y + 20);

            // Background particles
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                if (p.type === 'bossAppearFlash') {
                    ctx.fillStyle = `rgba(100, 0, 150, ${(p.life / p.maxLife) * 0.4})`;
                    ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);
                }
            }

            // PlayerÔºàÈÄüÂ∫¶‰Ωé‰∏ã‰∏≠„ÅØÈùí„Å£„ÅΩ„ÅèÔºâ
            if (player.invincibility % 4 < 2) {
                const px = player.x, py = player.y, pw = player.w, ph = player.h;
                ctx.strokeStyle = playerSlowTimer > 0 ? '#88aaff' : 'white';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(px + pw/2, py + 10, 10, 0, PI2);
                ctx.moveTo(px + pw/2, py + 20);
                ctx.lineTo(px + pw/2, py + 45);
                ctx.moveTo(px + pw/2, py + 45);
                ctx.lineTo(px + 5, py + ph);
                ctx.moveTo(px + pw/2, py + 45);
                ctx.lineTo(px + pw - 5, py + ph);
                ctx.moveTo(px + pw/2, py + 30);
                ctx.lineTo(player.punching > 0 ? (player.facing === 1 ? px + pw + 15 : px - 15) : px + (player.facing === 1 ? 25 : 5), py + (player.punching > 0 ? 30 : 40));
                ctx.stroke();
                
                // ÈÄüÂ∫¶‰Ωé‰∏ã„Ç®„Éï„Çß„ÇØ„Éà
                if (playerSlowTimer > 0 && frameCount % 10 < 5) {
                    ctx.strokeStyle = 'rgba(0, 150, 255, 0.5)';
                    ctx.lineWidth = 6;
                    ctx.stroke();
                }
            }

            // Enemies
            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                const scale = e.type === 'floor_boss' ? 1 : (e.isBoss ? 2 : (e.type === 'range' ? 1.6 : 1)) * GAME_CONFIG.IMAGE_SCALE;
                const drawW = e.w * (e.type === 'floor_boss' ? 1 : GAME_CONFIG.IMAGE_SCALE);
                const drawH = e.h * (e.type === 'floor_boss' ? 1 : GAME_CONFIG.IMAGE_SCALE);
                const drawX = e.x + (e.w - drawW) / 2;
                const drawY = e.y + e.h - drawH;

                if (e.type === 'heal') {
                    ctx.filter = 'hue-rotate(300deg) saturate(200%)';
                    if (frameCount % 20 >= 10) ctx.drawImage(e.img, drawX, drawY, drawW, drawH);
                } else if (e.type === 'range') {
                    ctx.filter = 'hue-rotate(180deg) saturate(150%) brightness(120%)';
                    ctx.drawImage(e.img, drawX, drawY, drawW, drawH);
                } else if (e.type === 'floor_boss') {
                    ctx.filter = 'none';
                    
                    // Á™ÅÈÄ≤‰∏≠„ÅØËµ§„Åè„Ç∞„É≠„Éº
                    if (e.isCharging) {
                        if (!liteMode) { ctx.shadowColor = '#ff6600'; ctx.shadowBlur = 25 + sin(frameCount * 0.3) * 10; }
                        ctx.filter = 'brightness(130%) saturate(150%)';
                    } else if (!liteMode) { 
                        ctx.shadowColor = 'purple'; 
                        ctx.shadowBlur = 15 + sin(frameCount * 0.1) * 8; 
                    }
                    
                    if (e.isFloating) {
                        ctx.globalAlpha = 0.6 + sin(frameCount * 0.15) * 0.2;
                        ctx.drawImage(e.img, drawX, drawY + sin(frameCount * 0.1) * 10, drawW, drawH);
                        ctx.globalAlpha = 1;
                    } else {
                        ctx.drawImage(e.img, drawX, drawY, drawW, drawH);
                    }
                    ctx.shadowBlur = 0;
                    ctx.filter = 'none';

                    // Attack warnings
                    if (e.attackState === 'warning') {
                        const pulse = 0.25 + sin(frameCount * 0.3) * 0.15;
                        if (e.attackType === 'beam') {
                            const beamY = GAME_CONFIG.GROUND_Y - GAME_CONFIG.BOSS_BEAM_HEIGHT / 2;
                            ctx.fillStyle = `rgba(150, 0, 255, ${pulse})`;
                            ctx.fillRect(0, beamY - GAME_CONFIG.BOSS_BEAM_HEIGHT, canvas.width, GAME_CONFIG.BOSS_BEAM_HEIGHT * 2);
                            ctx.strokeStyle = 'rgba(255, 0, 255, 0.6)';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([10, 10]);
                            ctx.beginPath();
                            ctx.moveTo(0, beamY - GAME_CONFIG.BOSS_BEAM_HEIGHT/2);
                            ctx.lineTo(canvas.width, beamY - GAME_CONFIG.BOSS_BEAM_HEIGHT/2);
                            ctx.moveTo(0, beamY + GAME_CONFIG.BOSS_BEAM_HEIGHT/2);
                            ctx.lineTo(canvas.width, beamY + GAME_CONFIG.BOSS_BEAM_HEIGHT/2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        } else if (e.attackType === 'area') {
                            const pulse2 = 0.4 + sin(frameCount * 0.4) * 0.2;
                            ctx.fillStyle = `rgba(255, 100, 0, ${pulse2})`;
                            ctx.beginPath();
                            ctx.arc(e.targetX, GAME_CONFIG.GROUND_Y - 10, 50, PI, 0, true);
                            ctx.fill();
                            ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
                            ctx.font = 'bold 24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('‚ö†', e.targetX, GAME_CONFIG.GROUND_Y - 60);
                        } else if (e.attackType === 'ceilingBeam') {
                            const pulse2 = 0.3 + sin(frameCount * 0.4) * 0.15;
                            ctx.fillStyle = `rgba(255, 50, 0, ${pulse2})`;
                            ctx.fillRect(e.targetX - GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH, 0, GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH * 2, GAME_CONFIG.GROUND_Y);
                            ctx.strokeStyle = 'rgba(255, 50, 0, 0.7)';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([15, 10]);
                            ctx.beginPath();
                            ctx.moveTo(e.targetX - GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH/2, 0);
                            ctx.lineTo(e.targetX - GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH/2, GAME_CONFIG.GROUND_Y);
                            ctx.moveTo(e.targetX + GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH/2, 0);
                            ctx.lineTo(e.targetX + GAME_CONFIG.BOSS_CEILING_BEAM_WIDTH/2, GAME_CONFIG.GROUND_Y);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        } else if (e.attackType === 'charge') {
                            // Á™ÅÈÄ≤„ÅÆË≠¶Âëä
                            const dir = player.x + player.w/2 > e.x + e.w/2 ? 1 : -1;
                            ctx.fillStyle = `rgba(255, 100, 0, ${pulse})`;
                            ctx.beginPath();
                            ctx.moveTo(e.x + e.w/2, e.y + e.h/2 - 20);
                            ctx.lineTo(e.x + e.w/2 + dir * 100, e.y + e.h/2);
                            ctx.lineTo(e.x + e.w/2, e.y + e.h/2 + 20);
                            ctx.fill();
                            ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
                            ctx.font = 'bold 20px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('Á™ÅÈÄ≤ÔºÅ', e.x + e.w/2 + dir * 60, e.y + e.h/2 - 30);
                        } else if (e.attackType === 'homing') {
                            // ËøΩÂ∞æÂºæ„ÅÆË≠¶Âëä
                            ctx.strokeStyle = `rgba(255, 0, 255, ${pulse + 0.3})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(e.x + e.w/2, e.y + e.h/2, 40 + sin(frameCount * 0.2) * 10, 0, PI2);
                            ctx.stroke();
                        } else if (e.attackType === 'slowMagic') {
                            // ÈÄüÂ∫¶‰Ωé‰∏ãÈ≠îÊ≥ï„ÅÆË≠¶Âëä
                            ctx.fillStyle = `rgba(0, 150, 255, ${pulse})`;
                            ctx.beginPath();
                            ctx.arc(e.targetX, GAME_CONFIG.GROUND_Y - 40, GAME_CONFIG.BOSS_SLOW_MAGIC_RADIUS, 0, PI2);
                            ctx.fill();
                            ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                            ctx.font = 'bold 18px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('üê¢', e.targetX, GAME_CONFIG.GROUND_Y - 70);
                        } else if (e.attackType === 'barrage') {
                            // ÂºæÂπï„ÅÆË≠¶Âëä
                            const barrageCount = calculateBossBarrageCount(e);
                            ctx.fillStyle = `rgba(255, 0, 100, ${pulse})`;
                            for (let j = 0; j < barrageCount; j++) {
                                const angle = (PI / 4) * (j / (barrageCount - 1) - 0.5) - PI/2;
                                ctx.beginPath();
                                ctx.arc(e.x + e.w/2 + cos(angle + PI/2) * 50, e.y + e.h/2 + sin(angle + PI/2) * 50, 8, 0, PI2);
                                ctx.fill();
                            }
                        }
                    }
                } else if (e.isBoss) {
                    ctx.filter = 'saturate(150%) brightness(120%)';
                    ctx.drawImage(e.img, drawX, drawY, drawW, drawH);
                } else {
                    ctx.filter = 'none';
                    ctx.drawImage(e.img, drawX, drawY, drawW, drawH);
                }
                ctx.filter = 'none';

                // HP bar
                if (e.isBoss || e.type === 'range' || e.hp < e.maxHp) {
                    const barY = drawY - 10;
                    ctx.fillStyle = 'rgba(100, 0, 0, 0.8)';
                    ctx.fillRect(e.x, barY, e.w, 5);
                    ctx.fillStyle = e.type === 'heal' ? 'pink' : (e.type === 'range' ? 'blue' : (e.type === 'floor_boss' ? 'purple' : '#00ff00'));
                    ctx.fillRect(e.x, barY, e.w * (e.hp / e.maxHp), 5);
                    
                    // „Éï„É≠„Ç¢„Éú„Çπ„ÅÆHPÈñæÂÄ§Ë°®Á§∫Ôºà30%„Åî„Å®Ôºâ
                    if (e.type === 'floor_boss') {
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                        ctx.lineWidth = 1;
                        for (let t = 0.3; t < 1; t += 0.3) {
                            const tx = e.x + e.w * t;
                            ctx.beginPath();
                            ctx.moveTo(tx, barY);
                            ctx.lineTo(tx, barY + 5);
                            ctx.stroke();
                        }
                    }
                }
            }

            // Projectiles
            for (let i = 0; i < projectiles.length; i++) {
                const p = projectiles[i];
                if (p.type === 'shortBeam') {
                    if (!liteMode) { ctx.shadowColor = 'orange'; ctx.shadowBlur = 8; }
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.ellipse(p.x + p.w/2, p.y + p.h/2, p.w/2, p.h/2, 0, 0, PI2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'spike') {
                    if (p.state === 'warning') {
                        ctx.fillStyle = `rgba(255, 0, 0, ${0.5 + sin(frameCount * 0.5) * 0.3})`;
                        ctx.fillRect(p.x - 25, GAME_CONFIG.GROUND_Y - 8, 50, 8);
                    } else if (p.state === 'active') {
                        ctx.fillStyle = '#444';
                        ctx.beginPath();
                        ctx.moveTo(p.x - p.w/2, GAME_CONFIG.GROUND_Y);
                        ctx.lineTo(p.x + p.w/2, GAME_CONFIG.GROUND_Y);
                        ctx.lineTo(p.x, GAME_CONFIG.GROUND_Y - p.h);
                        ctx.fill();
                    }
                } else if (p.type === 'bossBeam' && p.life > 0) {
                    ctx.fillStyle = 'rgba(150, 0, 255, 0.3)';
                    ctx.fillRect(0, p.y - p.h, p.x, p.h * 2);
                    if (!liteMode) { ctx.shadowColor = 'magenta'; ctx.shadowBlur = 15; }
                    ctx.fillStyle = 'rgba(255, 100, 255, 0.9)';
                    ctx.fillRect(0, p.y - p.h/2, p.x, p.h);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fillRect(0, p.y - p.h/4, p.x, p.h/2);
                    ctx.shadowBlur = 0;
                } else if (p.type === 'explosion') {
                    const prog = 1 - (p.life / GAME_CONFIG.BOSS_ATTACK_ACTIVE_FRAMES);
                    const rad = 50 + prog * 50;
                    const alpha = (1 - prog) * 0.8;
                    ctx.fillStyle = `rgba(255, 150, 0, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, GAME_CONFIG.GROUND_Y, rad, PI, 0, true);
                    ctx.fill();
                    ctx.fillStyle = `rgba(255, 255, 200, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(p.x, GAME_CONFIG.GROUND_Y, rad * 0.5, PI, 0, true);
                    ctx.fill();
                } else if (p.type === 'ceilingBeam' && p.life > 0) {
                    if (!liteMode) { ctx.shadowColor = 'red'; ctx.shadowBlur = 20; }
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.8)';
                    ctx.fillRect(p.x - 10, p.y, p.w + 20, p.h);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.fillRect(p.x + p.w/4, p.y, p.w/2, p.h);
                    ctx.shadowBlur = 0;
                } else if (p.type === 'barrage') {
                    // ÂºæÂπïÂºæ„ÅÆÊèèÁîª
                    if (!liteMode) { ctx.shadowColor = '#ff0066'; ctx.shadowBlur = 10; }
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.w/2, 0, PI2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.w/4, 0, PI2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'homing') {
                    // ËøΩÂ∞æÂºæ„ÅÆÊèèÁîª
                    if (!liteMode) { ctx.shadowColor = '#ff00ff'; ctx.shadowBlur = 12; }
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.w/2, 0, PI2);
                    ctx.fill();
                    // ÁõÆ„ÅÆ„Çà„ÅÜ„Å™Ê®°Êßò
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.w/4, 0, PI2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(p.x + p.vx * 0.5, p.y + p.vy * 0.5, 2, 0, PI2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'slowMagic') {
                    // ÈÄüÂ∫¶‰Ωé‰∏ãÈ≠îÊ≥ï„ÅÆÊèèÁîª
                    const alpha = p.life / p.maxLife;
                    const radius = GAME_CONFIG.BOSS_SLOW_MAGIC_RADIUS;
                    
                    // È≠îÊ≥ïÈô£„ÅÆ„Çà„ÅÜ„Å™„Ç®„Éï„Çß„ÇØ„Éà
                    ctx.strokeStyle = `rgba(0, 170, 255, ${alpha * 0.8})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y + radius, radius, 0, PI2);
                    ctx.stroke();
                    
                    // ÂÜÖÂÅ¥„ÅÆ„É™„É≥„Ç∞
                    ctx.strokeStyle = `rgba(100, 200, 255, ${alpha * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y + radius, radius * 0.6, 0, PI2);
                    ctx.stroke();
                    
                    // ‰∏≠ÂøÉ„ÅÆÊ∏¶
                    ctx.fillStyle = `rgba(0, 150, 255, ${alpha * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y + radius, radius, 0, PI2);
                    ctx.fill();
                    
                    // ÂõûËª¢„Åô„ÇãÊ®°Êßò
                    const rotAngle = frameCount * 0.05;
                    ctx.strokeStyle = `rgba(200, 230, 255, ${alpha * 0.5})`;
                    for (let j = 0; j < 4; j++) {
                        const a = rotAngle + (PI2 / 4) * j;
                        ctx.beginPath();
                        ctx.moveTo(p.x + cos(a) * radius * 0.3, p.y + radius + sin(a) * radius * 0.3);
                        ctx.lineTo(p.x + cos(a) * radius * 0.9, p.y + radius + sin(a) * radius * 0.9);
                        ctx.stroke();
                    }
                }
            }

            // Particles
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const alpha = p.maxLife ? p.life / p.maxLife : 1;

                if (p.type === 'beam') {
                    if (!liteMode) { ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 25; }
                    ctx.fillStyle = `rgba(0, 100, 150, ${alpha * 0.3})`;
                    ctx.fillRect(p.x, p.y - 5, p.w, p.h + 10);
                    const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
                    grad.addColorStop(0, `rgba(0, 200, 255, ${alpha * 0.7})`);
                    grad.addColorStop(0.5, `rgba(100, 255, 255, ${alpha * 0.9})`);
                    grad.addColorStop(1, `rgba(0, 200, 255, ${alpha * 0.7})`);
                    ctx.fillStyle = grad;
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                    ctx.fillRect(p.x, p.y + p.h/3, p.w, p.h/3);
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fillRect(p.x, p.y + p.h * 0.4, p.w, p.h * 0.2);
                    ctx.shadowBlur = 0;
                } else if (p.type === 'beamLightning') {
                    if (!p.segments.length) p.segments = generateLightningSegments(p.startX, p.width, p.direction, 15);
                    ctx.strokeStyle = `rgba(150, 255, 255, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = liteMode ? 5 : 15;
                    ctx.beginPath();
                    for (let j = 0; j < p.segments.length; j++) {
                        const seg = p.segments[j];
                        if (j === 0) ctx.moveTo(seg.x, p.y + seg.y + p.offsetY);
                        else ctx.lineTo(seg.x, p.y + seg.y + p.offsetY);
                    }
                    ctx.stroke();
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'beamMuzzleFlash') {
                    const sz = p.size * alpha;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = liteMode ? 10 : 30;
                    const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, sz);
                    grad.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    grad.addColorStop(0.3, `rgba(100, 255, 255, ${alpha * 0.8})`);
                    grad.addColorStop(0.7, `rgba(0, 200, 255, ${alpha * 0.4})`);
                    grad.addColorStop(1, 'rgba(0, 100, 150, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, sz, 0, PI2);
                    ctx.fill();
                    ctx.fillStyle = `rgba(200, 255, 255, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.ellipse(p.x + p.facing * sz * 0.5, p.y, sz * 1.5, sz * 0.3, 0, 0, PI2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'beamShockwave') {
                    ctx.strokeStyle = `rgba(100, 255, 255, ${alpha})`;
                    ctx.lineWidth = 3 * alpha;
                    ctx.beginPath();
                    ctx.ellipse(p.x, p.y, p.radius * 1.5, p.radius, 0, 0, PI2);
                    ctx.stroke();
                } else if (p.type === 'beamSpark') {
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    if (!liteMode) { ctx.shadowColor = p.color; ctx.shadowBlur = 5; }
                    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                } else if (SIMPLE_PARTICLES.has(p.type)) {
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    const sz = p.size || 4;
                    ctx.fillRect(p.x - sz/2, p.y - sz/2, sz, sz);
                    ctx.globalAlpha = 1;
                } else if (p.type === 'explosionRing') {
                    ctx.strokeStyle = `rgba(150, 0, 255, ${alpha})`;
                    ctx.lineWidth = 3 * alpha;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, PI2);
                    ctx.stroke();
                } else if (p.type === 'flash') {
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * (1.5 - alpha * 0.5), 0, PI2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else if (p.type === 'muzzleFlash') {
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = liteMode ? 5 : 15;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = `rgba(0, 200, 255, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.ellipse(p.x + p.facing * 20, p.y, 40 * alpha, 25 * alpha, 0, 0, PI2);
                    ctx.fill();
                    ctx.fillStyle = `rgba(200, 255, 255, ${alpha * 0.8})`;
                    ctx.beginPath();
                    ctx.ellipse(p.x + p.facing * 15, p.y, 25 * alpha, 15 * alpha, 0, 0, PI2);
                    ctx.fill();
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.ellipse(p.x + p.facing * 10, p.y, 15 * alpha, 8 * alpha, 0, 0, PI2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                } else if (p.type === 'chargeParticle') {
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                    ctx.globalAlpha = 1;
                }
            }

            // Âêπ„ÅçÂá∫„Åó„ÅÆÊèèÁîª
            drawSpeechBubble();

            // Damage texts
            ctx.font = 'bold 20px Arial';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.textAlign = 'left';
            for (let i = 0; i < damageTexts.length; i++) {
                const t = damageTexts[i];
                ctx.fillStyle = t.color || 'white';
                ctx.strokeText(t.text, t.x, t.y);
                ctx.fillText(t.text, t.x, t.y);
            }

            ctx.restore();

            // UI updates
            DOM.scoreBoard.textContent = `SCORE: ${score} (Stage: ${currentStage})`;
            DOM.hpBoard.textContent = `HP: ${player.hp}`;
            DOM.hpBoard.style.color = player.hp < 4 ? 'red' : 'lightgreen';

            const beamDmg = GAME_CONFIG.BASE_BEAM_DMG + player.punchDamage * 2;
            DOM.statusBoard.innerHTML = `PUNCH DMG: ${player.punchDamage}<br>BEAM DMG: ${beamDmg}<br>BEAM MULTI: x${player.beamMultiplier}`;

            if (player.beamCooldown > 0) {
                DOM.cdText.textContent = Math.ceil(player.beamCooldown / 60);
                DOM.cdText.style.color = 'gray';
                DOM.btnBeam.style.borderColor = 'gray';
            } else {
                DOM.cdText.textContent = 'OK';
                DOM.cdText.style.color = '#00ffff';
                DOM.btnBeam.style.borderColor = '#00ffff';
            }
        }

        function gameLoop() {
            if (gameState === 'PLAYING') {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
        }

        // Cookie functions
        function _saveCookie(name, val) { document.cookie = `${name}=${encodeURIComponent(val)}; max-age=${60*60*24*30}; path=/`; }
        function _loadCookie(name) { const m = document.cookie.match(new RegExp(`(?:^|; )${name}=([^;]*)`)); return m ? decodeURIComponent(m[1]) : null; }
        function _deleteCookie(name) { document.cookie = `${name}=; max-age=0; path=/`; }
        function updateSaveStateUI(text) { if (DOM.saveState) DOM.saveState.textContent = 'SAVE: ' + text; }

        function showTempMessage(text, bgColor) {
            const msg = document.createElement('div');
            msg.textContent = text;
            msg.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: ${bgColor}; color: white; padding: 15px 30px; border-radius: 8px; z-index: 1000; font-size: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.3);`;
            document.body.appendChild(msg);
            setTimeout(() => document.body.removeChild(msg), 2000);
        }

        function saveGameManual() {
            if (gameState !== 'PLAYING') return;
            try {
                _saveCookie('koyamaSave', JSON.stringify({
                    score, playerHP: player.hp, stage: currentStage,
                    punch: player.punchDamage, beamMulti: player.beamMultiplier, bossCount: floorBossCount
                }));
                updateSaveStateUI('SAVED');
                stopBGM();
                showTempMessage('„Çª„Éº„ÉñÂÆå‰∫ÜÔºÅ„Çø„Ç§„Éà„É´„Å´Êàª„Çä„Åæ„Åô...', '#48bb78');
                setTimeout(() => location.reload(), 1500);
            } catch (e) {
                showTempMessage('„Çª„Éº„ÉñÂ§±Êïó: ' + e.message, '#e53e3e');
            }
        }

        function loadGameData() {
            const raw = _loadCookie('koyamaSave');
            if (!raw) return false;
            try {
                const d = JSON.parse(raw);
                score = Number(d.score) || 0;
                player.hp = Number(d.playerHP) || player.hp;
                currentStage = previousStage = Number(d.stage) || 1;
                player.punchDamage = Number(d.punch) || 1;
                player.beamMultiplier = Number(d.beamMulti) || 1;
                floorBossCount = Number(d.bossCount) || 0;
                updateSaveStateUI('LOADED');
                return true;
            } catch { return false; }
        }

        // Game over save deletion
        (function() {
            let handled = false;
            setInterval(() => {
                if (!handled && gameState === 'GAMEOVER') { _deleteCookie('koyamaSave'); handled = true; }
                if (handled && gameState !== 'GAMEOVER') handled = false;
            }, 250);
        })();
    })();
    </script>
</body>
</html>
